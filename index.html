<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Leritura Python</title>
	<style type="text/css">
		body {
			background: #232526;
			color: #ACE8BA;
			width: 35%;
			margin: auto;
			text-align: justify;
			font-size: 18px;
			font-family: 'Roboto', sans-serif;
			opacity: 0.9;
		}

		h1 {
			color: forestgreen;
			text-align: center;
			font-family: 'Courier Prime', monospace;
		}

		h2 {
			text-align: left;
			font-family: 'Courier Prime', monospace;
		}

		h3 {
			text-align: left;
			font-family: 'Courier Prime', monospace;
		}

	    table {
	    	width: 100%;
	    	text-align: center;
	    	border-collapse: collapse;
	    }

	    table, td {
	    	border: 0.5px solid;
	    	padding: 5px 0 5px;
	    }

	    th {
	    	color: white;
	    }

		tr:nth-child(even) {
		    background: linear-gradient(#8c8c8c, #232526); 
		    opacity: 0.8 black; 
		    color:white; 
		    text-shadow: 1px 1px black; 
		}

		tr:nth-child(odd) {
		    background: linear-gradient(#232526, #8c8c8c); 
		    opacity: 0.8 black; 
		    color:white; 
		    text-shadow: 1px 1px black;	
		}

		a {
			color: inherit;
			opacity: .7;
			text-shadow: 1px 1px black;
			text-align: left;
		}

		a:hover {
			color: #FFFFFF;
			opacity: 1;
			text-align: left;
		}

		main {
			border: solid;
			padding: 12px;
		}

		sub {
			font-size: 14px;
			text-decoration: none;
		}

		.py-color {
			color: #558BB6;
		}

		.desabilitado {
			opacity: .2;
		}

		a.desabilitado {
			opacity: .2;
		}

		.a-indice {
			text-decoration: none;
			color: yellow;
			font-family: 'Courier Prime', monospace;
		}

		.a-pre {
			text-align: center;
			text-decoration: none;
			color: inherit;
		}

		.d-indice a:hover {
			font-family: 'Courier Prime', monospace;
			font-size: 20px;
			text-align: left;
		}

		.d-indice {
			margin-top: 50px;
			font-family: 'Josefin Sans', sans-serif;
		}

		.c-strong {
			color: #8c8c8c;
		}

		.observacao{
		    background-color: #3b3a3a;
		    padding: 20px 0px 20px 10px;
		    margin-bottom: 17px;
		    font-size: 15px;
		    font-family: 'JosefinSans-Regular', sans-serif;
		    border: 0.5px solid;
		}

		.observacao {
		  	color: rgba(255,255,255,0.6);
		    text-shadow: 1px 1px #000;
		}

		.exemplo {
		    background: black;
		    color: white;
		    padding: 1px;
		    overflow:auto;
		    margin-bottom: 25px;
		}

		.exemplo pre {
		    margin-left: -310px;
		}

		.p-code {
			color: white;
			text-shadow: 0.5px 0.5px black;
		}

		code.exemplo {
		    font-family: 'CourierPrime-Regular', monospace;
		    font-size: 14px;
		}

		@supports (display: flex) {
		  @media screen and (max-width: 780px) {
		    body {
		      width: 90%;
		    }
		  }
		}
	</style>
</head>

<body>
	<main>
		<div style="display: none;">
		</div>
		<h1 id="00" >Documentação <span class="py-color">Python</span> 3.10.2</h1>
			<a class="a-pre" href="https://docs.python.org/pt-br/3/" target="_blank">https://docs.python.org/pt-br/3/

			</a>
		<div class="d-indice">
			<a id="i-0" href="#0">Introdução</a><br><br>
			<a id="i-1" href="#1">1. Abrindo seu apetite</a><br>
			<a id="i-2" href="#2">2. Utilizando o interpretador Python</a><br>
			<a id="i-2.1" href="#2.1">2.1. Chamando o interpretador</a><br>
			<a id="i-2.1.1" href="#2.1.1">2.1.1. Passagem de argumentos</a><br>
			<a id="i-2.1.2" href="#2.1.2">2.1.2. Modo interativo</a><br>
			<a id="i-2.2" href="#2.2">2.2. O interpretador e seu ambiente</a><br>
			<a id="i-2.2.1" href="#2.2.1">2.2.1. Edição de código-fonte</a><br>
			<a id="i-3" href="#3">3. Uma introdução informal ao Python</a><br>
			<a id="i-3.1" href="#3.1">3.1. Usando <span class="py-color">Python</span> como uma calculadora</a><br>
			<a id="i-3.1.1" href="#3.1.1">3.1.1. Números</a><br>
			<a id="i-3.1.2" href="#3.1.2">3.1.2. Strings</a><br>
			<a id="i-3.1.3" href="#3.1.3">3.1.3. Listas</a><br>
			<a id="i-3.2" href="#3.2">3.2. Primeiros passos para a programação</a><br>
			<a id="i-4" href="#4">4. Mais ferramentas de controle de fluxo</a><br>
			<a id="i-4.1" href="#4.1">4.1. Comandos if</a><br>
			<a id="i-4.2" href="#4.2">4.2. Comandos for</a><br>
			<a id="i-4.3" href="#4.3">4.3. A função range()</a><br>
			<a id="i-4.4" href="#4.4">4.4. Comandos break e continue, e cláusula else, nos laços de repetição</a><br>
			<a id="i-4.5" href="#4.5">4.5. Comandos pass</a><br>
			<a id="i-4.6" href="#4.6">4.6. Instruções match</a><br>
			<a id="i-4.7" href="#4.7">4.7. Definindo funções</a><br>
			<a id="i-4.8" href="#4.8">4.8. Mais sobre definição de funções</a><br>
			<a id="i-4.8.1" href="#4.8.1">4.8.1. Argumentos com valor padrão</a><br>
			<a id="i-4.8.2" href="#4.8.2">4.8.2. Argumentos nomeados</a><br>
			<a id="i-4.8.3" href="#4.8.3">4.8.3. Parâmetros especiais</a><br>
			<a id="i-4.8.3.1" href="#4.8.3.1">4.8.3.1. Argumentos posicional-ou-nomeados</a><br>
			<a id="i-4.8.3.2" href="#4.8.3.2">4.8.3.2. Parâmetros somente-posicionais</a><br>
			<a id="i-4.8.3.3" href="#4.8.3.3">4.8.3.3. Argumentos somente-nomeados</a><br>
			<a id="i-4.8.3.4" href="#4.8.3.4">4.8.3.4. Exemplos de funções</a><br>
			<a id="i-4.8.3.5" href="#4.8.3.5">4.8.3.5. Recapitulando</a><br>
			<a id="i-4.8.4" href="#4.8.4">4.8.4. Listas de argumentos arbitrárias</a><br>
			<a id="i-4.8.5" href="#4.8.5">4.8.5. Desempacotando listas de argumentos</a><br>
			<a id="i-4.8.6" href="#4.8.6">4.8.6. Expressões lambda</a><br>
			<a id="i-4.8.7" href="#4.8.7">4.8.7. Strings de documentação</a><br>
			<a id="i-4.8.8" href="#4.8.8">4.8.8. Anotações de função</a><br>
			<a id="i-4.9" href="#4.9">4.9. Intermezzo: estilo de codificação</a><br>
			<a id="i-5" href="#5">5. Estruturas de dados</a><br>
			<a id="i-5.1" href="#5.1">5.1. Mais sobre listas</a><br>
			<a id="i-5.1.1" href="#5.1.1">5.1.1. Usando listas como pilhas</a><br>
			<a id="i-5.1.2" href="#5.1.2">5.1.2. Usando listas como filas</a><br>
			<a id="i-5.1.3" href="#5.1.3">5.1.3. Compreensões de lista</a><br>
			<a id="i-5.1.4" href="#5.1.4">5.1.4. Compreensões de lista aninhadas</a><br>
			<a id="i-5.2" href="#5.2">5.2. A instrução del</a><br>
			<a id="i-5.3" href="#5.3">5.3. Tuplas e Sequências</a><br>
			<a id="i-5.4" href="#5.4">5.4. Conjuntos</a><br>
			<a id="i-5.5" href="#5.5">5.5. Dicionários</a><br>
			<a id="i-5.6" href="#5.6">5.6. Técnicas de iteração</a><br>
			<a id="i-5.7" href="#5.7">5.7. Mais sobre condições</a><br>
			<a id="i-5.8" href="#5.8">5.8. Comparando sequências e outros tipos</a><br>
		</div>

		<h2 id="0">O tutorial de Python<a class="a-indice" href="#i-0"><sub>&nbsp;índice</sub></a></h2>
		<span class="py-color">Python</span> é uma linguagem fácil de aprender e poderosa.<br><br>

		Ela tem estruturas de dados de <strong class="c-strong">alto nível</strong> eficientes e uma abordagem simples mas efetiva de programação <strong class="c-strong">orientada a objetos</strong>.<br><br>

		A elegância de sintaxe e a <strong class="c-strong">tipagem dinâmica</strong> de <span class="py-color">Python</span> aliadas com sua natureza <strong class="c-strong">interpretativa</strong>, o fazem a linguagem ideal para programas e desenvolvimento de aplicações rápidas em diversas áreas e na maioria das plataformas.<br><br>

		O interpretador <span class="py-color">Python</span> e a extensiva biblioteca padrão estão disponíveis gratuitamente em código ou na forma binária para todas as maiores plataformas no endereço eletrônico do <a style="color:yellow;" href=" https://www.python.org/" target="_blank">Python</a>, e pode ser livremente distribuído.<br><br>

		O mesmo endereço contém distribuições de diversos módulos, programas e ferramentas gratuitos produzidos por terceiros e documentação adicional.<br><br>

		O interpretador <span class="py-color">Python</span> pode ser facilmente estendido com novas funções e tipos de dados implementados em C ou C++ (ou outras linguagens chamadas a partir de C).<br><br>

		<span class="py-color">Python</span> também é adequada como uma linguagem de extensão para aplicações personalizáveis.<br><br>

		Este tutorial introduz informalmente o leitor aos conceitos básicos e aos recursos da linguagem e do sistema <span class="py-color">Python</span>.<br><br>

		É mais fácil se você possuir um interpretador <span class="py-color">Python</span> para uma experiência prática, mas os exemplos são autossuficientes e, portanto, o tutorial pode apenas ser lido off-line também.<br><br>

		Para uma descrição detalhada dos módulos e objetos padrões, veja A Biblioteca Padrão do <span class="py-color">Python</span>.<br><br>

		Em A Referência da Linguagem <span class="py-color">Python</span> você encontra uma definição mais formal da linguagem.<br><br>

		Para escrever extensões em C ou C++ leia Estendendo e Incorporando o Interpretador <span class="py-color">Python</span> e Manual de referência da API <span class="py-color">Python</span>/C.<br><br>

		Existe também uma série de livros que cobrem <span class="py-color">Python</span> em profundidade.<br><br>

		Este tutorial não espera ser abrangente e cobrir todos os recursos ou mesmo os recursos mais usados.<br><br>

		Ele busca introduzir diversos dos recursos mais notáveis do <span class="py-color">Python</span> e lhe dará uma boa ideia do sabor e estilo da linguagem.<br><br>

		Depois de lê-lo, você terá condições de ler e escrever programas e módulos <span class="py-color">Python</span> e estará pronto para aprender mais sobre os diversos módulos descritos em A Biblioteca Padrão do <span class="py-color">Python</span>.<br><br>

		O Glossário também vale a pena ser estudado.<br><br>

		<h2 id="1">1. Abrindo seu apetite<a class="a-indice" href="#i-1"><sub>&nbsp;índice</sub></a></h2>
		Se você trabalha muito com computadores, acabará encontrando alguma tarefa que gostaria de automatizar.<br><br>

		Por exemplo, você pode querer fazer busca-e-troca em um grande número de arquivos de texto, ou renomear e reorganizar um monte de arquivos de fotos de uma maneira complicada.<br><br>

		Talvez você gostaria de escrever um pequeno banco de dados personalizado, ou um aplicativo GUI especializado, ou um jogo simples.<br><br>


		Se você é um desenvolvedor de software profissional, pode ter que trabalhar com várias bibliotecas C/C++/Java, mas o tradicional ciclo escrever/compilar/testar/recompilar é muito lento.<br><br>

		Talvez você esteja escrevendo um conjunto de testes para uma biblioteca e está achando tedioso codificar os testes.<br><br>

		Ou talvez você tenha escrito um programa que poderia utilizar uma linguagem de extensão, e você não quer conceber e implementar toda uma nova linguagem para sua aplicação.<br><br>

		<span class="py-color">Python</span> é a linguagem para você.<br><br>

		Você pode escrever um script de shell Unix ou arquivos em lote do Windows para algumas dessas tarefas, mas os scripts de shell são melhores para mover arquivos e alterar dados de texto, não são adequados para aplicativos ou jogos de GUI.<br><br>

		Você pode escrever um programa C/C++/Java, mas pode levar muito tempo de desenvolvimento para obter até mesmo um programa de primeiro rascunho.<br><br>

		<span class="py-color">Python</span> é mais simples de usar, está disponível nos sistemas operacionais Windows, macOS e Unix e ajudará você a fazer o trabalho mais rapidamente.<br><br>

		<span class="py-color">Python</span> é fácil de usar, sem deixar de ser uma linguagem de programação de verdade, oferecendo muito mais estruturação e suporte para programas extensos do que shell scripts ou arquivos de lote oferecem.<br><br>

		Por outro lado, <span class="py-color">Python</span> também oferece melhor verificação de erros do que C, e por ser uma linguagem de muito <strong class="c-strong">alto nível</strong>, ela possui tipos nativos de alto nível, tais como dicionários e vetores (arrays) flexíveis.<br><br>

		Devido ao suporte nativo a uma variedade de tipos de dados, <span class="py-color">Python</span> é aplicável a um domínio de problemas muito mais vasto do que Awk ou até mesmo Perl, ainda assim muitas tarefas são pelo menos tão fáceis em <span class="py-color">Python</span> quanto nessas linguagens.<br><br>

		<span class="py-color">Python</span> permite que você organize seu programa em módulos que podem ser reutilizados em outros programas escritos em Python.<br><br>

		A linguagem provê uma vasta coleção de módulos que podem ser utilizados como base para sua aplicação — ou como exemplos para estudo e aprofundamento.<br><br>

		Alguns desses módulos implementam manipulação de arquivos, chamadas do sistema, sockets, e até mesmo acesso a bibliotecas de construção de interfaces gráficas, como Tk.<br><br>

		<span class="py-color">Python</span> é uma <strong class="c-strong">linguagem interpretada</strong>, por isso você pode economizar um tempo considerável durante o desenvolvimento, uma vez que não há necessidade de compilação e vinculação (linking).<br><br>

		O interpretador pode ser usado interativamente, o que torna fácil experimentar diversas características da linguagem, escrever programas <q>descartáveis</q>, ou testar funções em um desenvolvimento debaixo para cima (bottom-up).<br><br>

		É também uma útil calculadora de mesa.<br><br>

		<span class="py-color">Python</span> permite a escrita de programas compactos e legíveis.<br><br>

		Programas escritos em <span class="py-color">Python</span> são tipicamente mais curtos do que seus equivalentes em C, C++ ou Java, por diversas razões:

		<ul>
			<li>os tipos de alto nível permitem que você expresse operações complexas em um único comando;</li>

			<li>a definição de bloco é feita por indentação ao invés de marcadores de início e fim de bloco;</li>

			<li>não há necessidade de declaração de variáveis ou parâmetros formais;</li>
		</ul>

		<span class="py-color">Python</span> é extensível: se você sabe como programar em C, é fácil adicionar funções ou módulos diretamente no interpretador, seja para desempenhar operações críticas em máxima velocidade, ou para vincular programas <span class="py-color">Python</span> a bibliotecas que só estejam disponíveis em formato binário (como uma biblioteca gráfica de terceiros).<br><br>

		Uma vez que você tenha sido fisgado, você pode vincular o interpretador <span class="py-color">Python</span> a uma aplicação escrita em C e utilizá-la como linguagem de comandos ou extensão para esta aplicação.<br><br>

		A propósito, a linguagem foi batizada a partir do famoso programa da BBC <q><em>Monty Python’s Flying Circus</em></q> e não tem nada a ver com répteis.<br><br>

		Fazer referências a citações do programa na documentação não é só permitido, como também é encorajado!

		Agora que você está entusiasmado com Python, vai querer conhecê-la com mais detalhes.<br><br>

		Partindo do princípio que a melhor maneira de aprender uma linguagem é usando-a, você está agora convidado a fazê-lo com este tutorial.<br><br>

		No próximo capítulo, a mecânica de utilização do interpretador é explicada.<br><br>

		Essa informação, ainda que mundana, é essencial para a experimentação dos exemplos apresentados mais tarde.<br><br>

		O resto do tutorial introduz diversos aspectos do sistema e linguagem <span class="py-color">Python</span> por intermédio de exemplos.<br><br>

		Serão abordadas expressões simples, comandos, tipos, funções e módulos.<br><br>

		Finalmente, serão explicados alguns conceitos avançados como exceções e classes definidas pelo usuário.<br><br>

		<h2 id="2">2. Utilizando o interpretador Python</h2>
		<h3 id="2.1">2.1. Chamando o interpretador<a class="a-indice" href="#i-2.1"><sub>&nbsp;índice</sub></a></h3>

		O interpretador Python é frequentemente instalado como /usr/local/bin/python3.10 nas máquinas onde está disponível; adicionando /usr/local/bin ao caminho de busca da shell de seu Unix torna-se possível iniciá-lo digitando o comando:<br><br>

		<div class="observacao">
			python3.10
		</div>

		no shell [1] Considerando que a escolha do diretório onde o interpretador está é uma opção de instalação, outros locais são possíveis; verifique com seu guru local de Python ou administrador do sistema local.<br><br>

		(Por exemplo, /usr/local/python é um local alternativo popular).<br><br>

		Em máquinas Windows onde você instalou Python a partir da Microsoft Store, o comando python3.10 estará disponível.<br><br>

		Se você tem o lançador py.exe instalado, você pode usar o comando py.<br>
		Veja Excursus: Configurando variáveis de ambiente para outras maneiras de executar o Python.<br><br>

		Digitando um caractere de fim-de-arquivo (Control-D no Unix, Control-Z no Windows) diretamente no prompt força o interpretador a sair com status de saída zero.<br><br>

		Se isso não funcionar, você pode sair do interpretador digitando o seguinte comando: quit().<br><br>

		Os recursos de edição de linha do interpretador incluem edição interativa, substituição de histórico e complemento de código, em sistemas com suporte à biblioteca GNU Readline.<br><br>

		Talvez a verificação mais rápida para ver se o suporte à edição de linha de comando está disponível é digitando Control-P no primeiro prompt oferecido pelo Python.<br><br>

		Se for emitido um bipe, você terá a edição da linha de comando; veja Apêndice Edição de entrada interativa e substituição de histórico para uma introdução às combinações.<br><br>

		Se nada acontecer, ou se ^P aparecer na tela, a edição da linha de comando não está disponível; você só poderá usar backspace para remover caracteres da linha atual.<br><br>

		O interpretador trabalha de forma semelhante a uma shell de Unix: quando chamado com a saída padrão conectada a um console de terminal, ele lê e executa comandos interativamente; quando chamado com um nome de arquivo como argumento, ou com redirecionamento da entrada padrão para ler um arquivo, o interpretador lê e executa o script contido no arquivo.<br><br>

		Uma segunda forma de iniciar o interpretador é python -c comando [arg], que executa uma ou mais instruções especificadas na posição comando, analogamente à opção de shell -c.<br><br>

		Considerando que comandos Python frequentemente têm espaços em branco (ou outros caracteres que são especiais para a shell) é aconselhável que o comando esteja dentro de aspas duplas.<br><br>

		Alguns módulos Python são também úteis como scripts.<br><br>
		Estes podem ser chamados usando python -m módulo [arg] que executa o arquivo fonte do módulo como se

		você tivesse digitado seu caminho completo na linha de comando.<br><br>

		Quando um arquivo de script é utilizado, às vezes é útil executá-lo e logo em seguida entrar em modo interativo.<br><br>

		Isto pode ser feito acrescentando o argumento -i antes do nome do script.<br><br>

		Todas as opções de linha de comando são descritas em Linha de comando e ambiente.<br><br>

		<h3 id="2.1.1">2.1.1. Passagem de argumentos<a class="a-indice" href="#i-2.1.1"><sub>&nbsp;índice</sub></a></h3>

		Quando são de conhecimento do interpretador, o nome do script e demais argumentos da linha de comando da shell são acessíveis ao próprio script através da variável argv do módulo sys. Pode-se acessar essa lista executando import sys.<br><br>

		Essa lista tem sempre ao menos um elemento; quando nenhum script ou argumento for passado para o interpretador, sys.argv[0] será uma string vazia. Quando o nome do script for '-' (significando entrada padrão), o conteúdo de sys.argv[0] será '-'. Quando for utilizado -c comando, sys.argv[0] conterá '-c'.<br><br>

		Quando for utilizado -m módulo, sys.argv[0] conterá o caminho completo do módulo localizado.<br><br>

		Opções especificadas após -c comando ou -m módulo não serão consumidas pelo interpretador mas deixadas em sys.argv para serem tratadas pelo comando ou módulo.<br><br>

		<h3 id="2.1.2">2.1.2. Modo interativo<a class="a-indice" href="#i-2.1.2"><sub>&nbsp;índice</sub></a></h3>

		Quando os comandos são lidos a partir do console, diz-se que o interpretador está em modo interativo.<br><br>

		Nesse modo ele solicita um próximo comando através do prompt primário, tipicamente três sinais de maior (>>>); para linhas de continuação do comando atual, o prompt secundário padrão é formado por três pontos (...). O interpretador exibe uma mensagem de boas vindas, informando seu número de versão e um aviso de copyright antes de exibir o primeiro prompt:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				$ python3.10
				Python 3.10 (default, June 4 2019, 09:25:04)
				[GCC 4.8.2] on linux
				Type "help", "copyright", "credits" or "license" for more information.
				>>>
				</code>
			</pre>
		</div>


		Linhas de continuação são necessárias em construções multi-linha. Como exemplo, dê uma olhada nesse comando if:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> the_world_is_flat = True
				>>> if the_world_is_flat:
				...     print("Be careful not to fall off!")
				...
				Be careful not to fall off!
				</code>
			</pre>
		</div>

		Para mais informações sobre o modo interativo, veja Modo interativo.

		<h2 id="2.2">2.2. O interpretador e seu ambiente</h2>
		<h3 id="2.2.1">2.2.1. Edição de código-fonte<a class="a-indice" href="#i-2.2.1"><sub>&nbsp;índice</sub></a></h3>
		Por padrão, arquivos fonte de Python são tratados com codificação UTF-8.<br><br>

		Nessa codificação, caracteres de muitos idiomas no mundo podem ser usados simultaneamente em literais string, identificadores e comentários — embora a biblioteca padrão use apenas caracteres ASCII para identificadores, uma convenção que qualquer código portável deve seguir.<br><br>

		Para exibir todos esses caracteres corretamente, seu editor deve reconhecer que o arquivo é UTF-8 e deve usar uma fonte com suporte a todos os caracteres no arquivo.<br><br>

		Para declarar uma codificação diferente da padrão, uma linha de comentário especial deve ser adicionada como primeira linha do arquivo. A sintaxe é essa:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				# -*- coding: encoding -*-
				</code>
			</pre>
		</div>

		onde encoding é uma das codecs válidas com suporte do Python.<br><br>

		Por exemplo, para declarar que a codificação Windows-1252 deve ser usada, a primeira linha do seu arquivo fonte deve ser:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				# -*- coding: cp1252 -*-
				</code>
			</pre>
		</div>

		Uma exceção para a regra da primeira linha é quando o código-fonte inicia com uma linha com UNIX “shebang”.<br><br>

		Nesse caso, a declaração de codificação deve ser adicionada como a segunda linha do arquivo. Por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				#!/usr/bin/env python3
				# -*- coding: cp1252 -*-
				</code>
			</pre>
		</div>

		<blockquote>
			Notas de rodapé<br>
			1 No Unix, o interpretador Python 3.x não é instalado por padrão com o executável nomeado python, então não vai conflitar com um executável Python 2.x instalado simultaneamente.
		</blockquote>

		<h2 id="3">3. Uma introdução informal ao Python<a class="a-indice" href="#i-3"><sub>&nbsp;índice</sub></a></h2>
		Nos exemplos seguintes, pode-se distinguir entrada e saída pela presença ou ausência dos prompts (>>> e …): para repetir o exemplo, você deve digitar tudo após o prompt, quando o mesmo aparece; linhas que não começarem com um prompt são na verdade as saídas geradas pelo interpretador.<br><br>

		Observe que quando aparece uma linha contendo apenas o prompt secundário você deve digitar uma linha em branco; é assim que se encerra um comando de múltiplas linhas.<br><br>

		Você pode alternar a exibição de prompts e saída clicando em >>> no canto superior direito de uma caixa de exemplo. Se você ocultar os prompts e a saída para um exemplo, poderá copiar e colar facilmente as linhas de entrada em seu interpretador.<br><br>

		Muitos exemplos neste manual, mesmo aqueles inscritos na linha de comando interativa, incluem comentários. Comentários em Python começam com o caractere cerquilha ‘#’ e estende até o final da linha.<br><br>

		Um comentário pode aparecer no inicio da linha ou após espaço em branco ou código, mas não dentro de uma string literal. O caracterer cerquilha dentro de uma string literal é apenas uma cerquilha.<br><br>

		Como os comentários são para esclarecer o código e não são interpretados pelo Python, eles podem ser omitidos ao digitar exemplos.<br><br>

		<strong>Alguns exemplos:</strong><br><br>

		<div class="exemplo">
			<pre>
				<code>
				# this is the first comment
				spam = 1  # and this is the second comment
				          # ... and now a third!
				text = "# This is not a comment because it's inside quotes."
				</code>
			</pre>
		</div>

		<h3 id="3.1">3.1. Usando Python como uma calculadora<a class="a-indice" href="#i-3.1"><sub>&nbsp;índice</sub></a></h3>		
		Vamos experimentar alguns comandos simples em Python. Inicie o interpretador e aguarde o prompt primário, >>>. (Não deve demorar muito).<br><br>

		<h3 id="3.1.1">3.1.1. Números<a class="a-indice" href="#i-3.1.1"><sub>&nbsp;índice</sub></a></h3>
		O interpretador funciona como uma calculadora bem simples: você pode digitar uma expressão e o resultado será apresentado. A sintaxe de expressões é a usual: operadores +, -, * e / funcionam da mesma forma que em outras linguagens tradicionais (por exemplo, Pascal ou C); parênteses (()) podem ser usados para agrupar expressões. Por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> 2 + 2
				4
				>>> 50 - 5*6
				20
				>>> (50 - 5*6) / 4
				5.0
				>>> 8 / 5  # division always returns a floating point number
				1.6
				</code>
			</pre>
		</div>

		Os números inteiros (ex. 2, 4, 20) são do tipo int, aqueles com parte fracionária (ex. 5.0, 1.6) são do tipo float. Veremos mais sobre tipos numéricos posteriormente neste tutorial.<br><br>

		Divisão (/) sempre retorna ponto flutuante (float). Para fazer uma divisão pelo piso e receber um inteiro como resultado (descartando a parte fracionária) você pode usar o operador //; para calcular o resto você pode usar o %:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> 17 / 3  # classic division returns a float
				5.666666666666667
				>>>
				>>> 17 // 3  # floor division discards the fractional part
				5
				>>> 17 % 3  # the % operator returns the remainder of the division
				2
				>>> 5 * 3 + 2  # floored quotient * divisor + remainder
				</code>
			</pre>
		</div>

		Com Python, é possível usar o operador ** para calcular potências 1:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> 5 ** 2  # 5 squared
				25
				>>> 2 ** 7  # 2 to the power of 7
				128
				</code>
			</pre>
		</div>

		O sinal de igual ('=') é usado para atribuir um valor a uma variável. Depois de uma atribuição, nenhum resultado é exibido antes do próximo prompt:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> width = 20
				>>> height = 5 * 9
				>>> width * height
				900	
				</code>
			</pre>
		</div>

		Se uma variável não é “definida” (não tem um valor atribuído), tentar utilizá-la gerará um erro:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> n  # try to access an undefined variable
				Traceback (most recent call last):
				File "<stdin>", line 1, in <module>
				NameError: name 'n' is not defined
				</code>
			</pre>
		</div>

		Há suporte completo para ponto flutuante (float); operadores com operandos de diferentes tipos convertem o inteiro para ponto flutuante:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> 4 * 3.75 - 1
				14.0				
				</code>
			</pre>
		</div>

		No modo interativo, o valor da última expressão exibida é atribuída a variável _. Assim, ao utilizar Python como uma calculadora, fica mais fácil prosseguir com os cálculos, por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> tax = 12.5 / 100
				>>> price = 100.50
				>>> price * tax
				12.5625
				>>> price + _
				113.0625
				>>> round(_, 2)
				113.06					
				</code>
			</pre>
		</div>

		Essa variável especial deve ser tratada como somente para leitura pelo usuário. Nunca lhe atribua explicitamente um valor — do contrário, estaria criando uma outra variável (homônima) independente, que mascararia a variável especial com seu comportamento mágico.<br><br>

		Além de int e float, o Python suporta outros tipos de números, tais como Decimal e Fraction. O Python também possui suporte nativo a números complexos, e usa os sufixos j ou J para indicar a parte imaginária (por exemplo, 3+5j).<br><br>

		Além de números, Python também pode manipular strings (sequências de caracteres), que podem ser expressas de diversas formas. Elas podem ser delimitadas por aspas simples ('...') ou duplas ("...") e teremos o mesmo resultado 2. \ pode ser usada para escapar aspas:<br><br>

		<h3 id="3.1.2">3.1.2. Strings<a class="a-indice" href="#i-3.1.2"><sub>&nbsp;índice</sub></a></h3>

		<div class="exemplo">
			<pre>
				<code>
				>>> 'spam eggs'  # single quotes
				'spam eggs'
				>>> 'doesn\'t'  # use \' to escape the single quote...
				"doesn't"
				>>> "doesn't"  # ...or use double quotes instead
				"doesn't"
				>>> '"Yes," they said.'
				'"Yes," they said.'
				>>> "\"Yes,\" they said."
				'"Yes," they said.'
				>>> '"Isn\'t," they said.'
				'"Isn\'t," they said.'	
				</code>
			</pre>
		</div>

		Na interpretação interativa, a string de saída é delimitada com aspas e caracteres especiais são escapados com barras invertidas. Embora isso possa às vezes parecer diferente da entrada (as aspas podem mudar), as duas strings são equivalentes. A string é delimitada com aspas duplas se a string contiver uma única aspa simples e nenhuma aspa dupla, caso contrário, ela é delimitada com aspas simples. A função print() produz uma saída mais legível, ao omitir as aspas e ao imprimir caracteres escapados e especiais:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>> '"Isn\'t," they said.'
				'"Isn\'t," they said.'
				>>> print('"Isn\'t," they said.')
				"Isn't," they said.
				>>> s = 'First line.\nSecond line.'  # \n means newline
				>>> s  # without print(), \n is included in the output
				'First line.\nSecond line.'
				>>> print(s)  # with print(), \n produces a new line
				First line.
				Second line.	
				</code>
			</pre>
		</div>

		Se não quiseres que os caracteres sejam precedidos por \ para serem interpretados como caracteres especiais, poderás usar strings raw (N.d.T: “crua” ou sem processamento de caracteres de escape) adicionando um r antes da primeira aspa:<br><br>

	    <div class="exemplo">
			<pre>
				<code>
				>>>
				>>> print('C:\some\name')  # here \n means newline!
				C:\some
				ame
				>>> print(r'C:\some\name')  # note the r before the quote
				C:\some\name
				</code>
			</pre>
	    </div>

		As strings literais podem abranger várias linhas. Uma maneira é usar as aspas triplas: """...""" ou '''...'''. O fim das linhas é incluído automaticamente na string, mas é possível evitar isso adicionando uma \ no final. O seguinte exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				print("""\
				Usage: thingy [OPTIONS]
				 -h                        Display this usage message
				 -H hostname               Hostname to connect to
				""")
				produz a seguinte saída (observe que a linha inicial não está incluída):

				Usage: thingy [OPTIONS]
				 -h                        Display this usage message
				 -H hostname               Hostname to connect to
			 </code>
			</pre>
		</div>

		Strings podem ser concatenadas (coladas) com o operador +, e repetidas com *:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> # 3 times 'un', followed by 'ium'
				>>> 3 * 'un' + 'ium'
				'unununium'

				Duas ou mais strings literais (ou seja, entre aspas) ao lado da outra são automaticamente concatenados.<br><br>

				>>>
				>>> 'Py' 'thon'
				'Python'	
				</code>
			</pre>
		</div>

		Esse recurso é particularmente útil quando você quer quebrar strings longas:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> text = ('Put several strings within parentheses '
				...         'to have them joined together.')
				>>> text
				'Put several strings within parentheses to have them joined together.'	
				</code>
			</pre>
		</div>

		Isso só funciona com duas strings literais, não com variáveis ou expressões:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> prefix = 'Py'
				>>> prefix 'thon'  # can't concatenate a variable and a string literal
				  File "<stdin>", line 1
				    prefix 'thon'
				                ^
				SyntaxError: invalid syntax
				>>> ('un' * 3) 'ium'
				  File "<stdin>", line 1
				    ('un' * 3) 'ium'
				                   ^
				SyntaxError: invalid 	
				</code>
			</pre>
		</div>

		Se você quiser concatenar variáveis ou uma variável e uma literal, use +:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> prefix + 'thon'
				'Python'	
				</code>
			</pre>
		</div>

		As strings podem ser indexadas (subscritas), com o primeiro caractere como índice 0. Não existe um tipo específico para caracteres; um caractere é simplesmente uma string cujo tamanho é 1:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word = 'Python'
				>>> word[0]  # character in position 0
				'P'
				>>> word[5]  # character in position 5
				'n'	
				</code>
			</pre>
		</div>

		Índices também podem ser números negativos para iniciar a contagem pela direita:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word[-1]  # last character
				'n'
				>>> word[-2]  # second-last character
				'o'
				>>> word[-6]
				'P'	
				</code>
			</pre>
		</div>

		Note que dado que -0 é o mesmo que 0, índices negativos começam em -1.<br><br>

		Além da indexação, o fatiamento também é permitido. Embora a indexação seja usada para obter caracteres individuais, fatiar permite que você obtenha substring:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word[0:2]  # characters from position 0 (included) to 2 (excluded)
				'Py'
				>>> word[2:5]  # characters from position 2 (included) to 5 (excluded)
				'tho'	
				</code>
			</pre>
		</div>

		Os índices do fatiamento possuem padrões úteis; um primeiro índice omitido padrão é zero, um segundo índice omitido é por padrão o tamanho da string sendo fatiada:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word[:2]   # character from the beginning to position 2 (excluded)
				'Py'
				>>> word[4:]   # characters from position 4 (included) to the end
				'on'
				>>> word[-2:]  # characters from the second-last (included) to the end
				'on'	
				</code>
			</pre>
		</div>

		Observe como o início sempre está incluído, e o fim sempre é excluído. Isso garante que s[:i] + s[i:] seja sempre igual a s:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word[:2] + word[2:]
				'Python'
				>>> word[:4] + word[4:]
				'Python'	
				</code>
			</pre>
		</div>

		Uma maneira de lembrar como fatias funcionam é pensar que os índices indicam posições entre caracteres, onde a borda esquerda do primeiro caractere é 0. Assim, a borda direita do último caractere de uma string de comprimento n tem índice n, por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				 +---+---+---+---+---+---+
				 | P | y | t | h | o | n |
				 +---+---+---+---+---+---+
				 0   1   2   3   4   5   6
				-6  -5  -4  -3  -2  -1	
				</code>
			</pre>
		</div>

		A primeira fileira de números indica a posição dos índices 0…6 na string; a segunda fileira indica a posição dos respectivos índices negativos. Uma fatia de i a j consiste em todos os caracteres entre as bordas i e j, respectivamente.<br><br>

		Para índices positivos, o comprimento da fatia é a diferença entre os índices, se ambos estão dentro dos limites da string. Por exemplo, o comprimento de word[1:3] é 2.<br><br>

		A tentativa de usar um índice que seja muito grande resultará em um erro:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word[42]  # the word only has 6 characters
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				IndexError: string index out of range	
				</code>
			</pre>
		</div>

		No entanto, os índices de fatiamento fora do alcance são tratados graciosamente (N.d.T: o termo original “gracefully” indica robustez no tratamento de erros) quando usados para fatiamento. Um índice maior que o comprimento é trocado pelo comprimento, um limite superior menor que o limite inferior produz uma string vazia:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word[4:42]
				'on'
				>>> word[42:]
				''	
				</code>
			</pre>
		</div>
		As strings do Python não podem ser alteradas — uma string é imutável. Portanto, atribuir a uma posição indexada na sequência resulta em um erro:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> word[0] = 'J'
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: 'str' object does not support item assignment
				>>> word[2:] = 'py'
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: 'str' object does not support item assignment	
				</code>
			</pre>
		</div>

		Se você precisar de uma string diferente, deverá criar uma nova:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> 'J' + word[1:]
				'Jython'
				>>> word[:2] + 'py'
				'Pypy'	
				</code>
			</pre>
		</div>

		A função embutida len() devolve o comprimento de uma string:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> s = 'supercalifragilisticexpialidocious'
				>>> len(s)
				34	
				</code>
			</pre>
		</div>

		Ver também<br>
		Tipo sequência de texto — str
		As strings são exemplos de tipos de sequências e suportam as operações comumente suportadas por esses tipos.<br><br>

		Métodos de string<br>
		As strings suportam uma grande quantidade de métodos para transformações básicas e busca.<br><br>

		Literais de string formatados<br>
		Strings literais que possuem expressões embutidas.<br><br>

		Sintaxe das strings de formato<br>
		Informações sobre formatação de string com o método str.format().<br><br>

		Formatação de String no Formato printf-style<br>
		As antigas operações de formatação invocadas quando as strings são o operando esquerdo do operador % são descritas com mais detalhes aqui.<br><br>

		<h3 id="3.1.3">3.1.3. Listas<a class="a-indice" href="#i-3.1.3"><sub>&nbsp;índice</sub></a></h3>
		Python inclui diversas estruturas de dados compostas, usadas para agrupar outros valores. A mais versátil é list (lista), que pode ser escrita como uma lista de valores (itens) separados por vírgula, entre colchetes. Os valores contidos na lista não precisam ser todos do mesmo tipo.<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> squares = [1, 4, 9, 16, 25]
				>>> squares
				[1, 4, 9, 16, 25]	
				</code>
			</pre>
		</div>

		Como strings (e todos os tipos embutidos de sequência), listas pode ser indexados e fatiados:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> squares[0]  # indexing returns the item
				1
				>>> squares[-1]
				25
				>>> squares[-3:]  # slicing returns a new list
				[9, 16, 25]	
				</code>
			</pre>
		</div>

		Todas as operações de fatiamento devolvem uma nova lista contendo os elementos solicitados. Isso significa que o seguinte fatiamento devolve uma cópia rasa da lista:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> squares[:]
				[1, 4, 9, 16, 25]	
				</code>
			</pre>
		</div>

		As listas também suportam operações como concatenação:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> squares + [36, 49, 64, 81, 100]
				[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]	
				</code>
			</pre>
		</div>

		Diferentemente de strings, que são imutáveis, listas são mutáveis, ou seja, é possível alterar elementos individuais de uma lista:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> cubes = [1, 8, 27, 65, 125]  # something's wrong here
				>>> 4 ** 3  # the cube of 4 is 64, not 65!
				64
				>>> cubes[3] = 64  # replace the wrong value
				>>> cubes
				[1, 8, 27, 64, 125]	
				</code>
			</pre>
		</div>

		Você também pode adicionar novos itens no final da lista, usando o método append() (estudaremos mais a respeito dos métodos posteriormente):<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> cubes.append(216)  # add the cube of 6
				>>> cubes.append(7 ** 3)  # and the cube of 7
				>>> cubes
				[1, 8, 27, 64, 125, 216, 343]	
				</code>
			</pre>
		</div>

		Atribuição a fatias também é possível, e isso pode até alterar o tamanho da lista ou remover todos os itens dela:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
				>>> letters
				['a', 'b', 'c', 'd', 'e', 'f', 'g']
				>>> # replace some values
				>>> letters[2:5] = ['C', 'D', 'E']
				>>> letters
				['a', 'b', 'C', 'D', 'E', 'f', 'g']
				>>> # now remove them
				>>> letters[2:5] = []
				>>> letters
				['a', 'b', 'f', 'g']
				>>> # clear the list by replacing all the elements with an empty list
				>>> letters[:] = []
				>>> letters
				[]	
				</code>
			</pre>
		</div>

		A função embutida len() também se aplica a listas:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> letters = ['a', 'b', 'c', 'd']
				>>> len(letters)
				4	
				</code>
			</pre>
		</div>

		É possível aninhar listas (criar listas contendo outras listas), por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> a = ['a', 'b', 'c']
				>>> n = [1, 2, 3]
				>>> x = [a, n]
				>>> x
				[['a', 'b', 'c'], [1, 2, 3]]
				>>> x[0]
				['a', 'b', 'c']
				>>> x[0][1]
				'b'	
				</code>
			</pre>
		</div>
		
		<h3 id="3.2">3.2. Primeiros passos para a programação<a class="a-indice" href="#i-3.2"><sub>&nbsp;índice</sub></a></h3>
		Claro, podemos usar o Python para tarefas mais complicadas do que somar 2+2. Por exemplo, podemos escrever o início da sequência de Fibonacci assim:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> # Fibonacci series:
				... # the sum of two elements defines the next
				... a, b = 0, 1
				>>> while a < 10:
				...     print(a)
				...     a, b = b, a+b
				...
				0
				1
				1
				2
				3
				5
				8	
				</code>
			</pre>
		</div>

		Este exemplo introduz diversas características ainda não mencionadas.<br><br>

		A primeira linha contém uma atribuição múltipla: as variáveis a e b recebem simultaneamente os novos valores 0 e 1. Na última linha há outro exemplo de atribuição múltipla demonstrando que expressões do lado direito são sempre avaliadas primeiro, antes da atribuição. As expressões do lado direito são avaliadas da esquerda para a direita.<br><br>

		O laço de repetição while executa enquanto a condição (aqui: a < 10) permanece verdadeira. Em Python, como em C, qualquer valor inteiro que não seja zero é considerado verdadeiro; zero é considerado falso. A condição pode também ser uma cadeia de caracteres ou uma lista, ou qualquer sequência; qualquer coisa com um tamanho maior que zero é verdadeiro, enquanto sequências vazias são falsas. O teste usado no exemplo é uma comparação simples. Os operadores padrões de comparação são os mesmos de C: < (menor que), > (maior que), == (igual), <= (menor ou igual), >= (maior ou igual) e != (diferente).<br><br>

		O corpo do laço é indentado: indentação em Python é a maneira de agrupar comandos em blocos. No console interativo padrão você terá que digitar tab ou espaços para indentar cada linha. Na prática você vai preparar scripts Python mais complicados em um editor de texto; a maioria dos editores de texto tem facilidades de indentação automática. Quando um comando composto é digitado interativamente, deve ser finalizado por uma linha em branco (já que o interpretador não tem como adivinhar qual é a última linha do comando). Observe que toda linha de um mesmo bloco de comandos deve ter a mesma indentação.<br><br>

		A função print() escreve o valor dos argumentos fornecidos. É diferente de apenas escrever a expressão no interpretador (como fizemos anteriormente nos exemplos da calculadora) pela forma como lida com múltiplos argumentos, quantidades de ponto flutuante e strings. As strings são impressas sem aspas, e um espaço é inserido entre os itens, assim você pode formatar bem o resultado, dessa forma:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> i = 256*256
				>>> print('The value of i is', i)
				The value of i is 65536	
				</code>
			</pre>
		</div>	
		O argumento end pode ser usado para evitar uma nova linha após a saída ou finalizar a saída com uma string diferente:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> a, b = 0, 1
				>>> while a < 1000:
				...     print(a, end=',')
				...     a, b = b, a+b
				...
				0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,	
				</code>
			</pre>
		</div>

		<blockquote>
			Notas de rodapé<br>
			1 Uma vez que ** tem precedência mais alta que -, -3**2 será interpretado como -(3**2) e assim resultará em -9. Para evitar isso e obter 9, você pode usar (-3)**2.<br>
			2 Ao contrário de outras linguagens, caracteres especiais como \n têm o mesmo significado com as aspas simples ('...') e duplas ("...") . A única diferença entre as duas é que, dentro de aspas simples, você não precisa escapar o " (mas você deve escapar a \') e vice-versa.
		</blockquote>

		<h3 id="4">4. Mais ferramentas de controle de fluxo<a class="a-indice" href="#i-4"><sub>&nbsp;índice</sub></a></h3>
		Além do comando while recém apresentado, Python tem as estruturas usuais de controle de fluxo conhecidas em outras linguagens, com algumas particulares.<br><br>

		<h3 id="4.1">4.1. Comandos if<a class="a-indice" href="#i-4.1"><sub>&nbsp;índice</sub></a></h3>
		Provavelmente o mais conhecido comando de controle de fluxo é o if. Por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> x = int(input("Please enter an integer: "))
				Please enter an integer: 42
				>>> if x < 0:
				...     x = 0
				...     print('Negative changed to zero')
				... elif x == 0:
				...     print('Zero')
				... elif x == 1:
				...     print('Single')
				... else:
				...     print('More')
				...	
				</code>
			</pre>
		</div>

		More<br>
		Pode haver zero ou mais partes elif, e a parte else é opcional. A palavra-chave ‘elif’ é uma abreviação para ‘else if’, e é útil para evitar indentação excessiva. Uma sequência if … elif … elif … substitui os comandos switch ou case, encontrados em outras linguagens.<br><br>

		Se você está comparando o mesmo valor com várias constantes, ou verificando por tipos ou atributos específicos, você também pode achar a instrução match útil. Para mais detalhes veja Instruções match.<br><br>

		<h3 id="4.2">4.2. Comandos for<a class="a-indice" href="#i-4.2"><sub>&nbsp;índice</sub></a></h3>		
		O comando for em Python é um pouco diferente do que costuma ser em C ou Pascal. Ao invés de sempre iterar sobre uma progressão aritmética de números (como no Pascal), ou permitir ao usuário definir o passo de iteração e a condição de parada (como C), o comando for do Python itera sobre os itens de qualquer sequência (seja uma lista ou uma string), na ordem que aparecem na sequência. Por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> # Measure some strings:
				... words = ['cat', 'window', 'defenestrate']
				>>> for w in words:
				...     print(w, len(w))
				...
				cat 3
				window 6
				defenestrate 12	
				</code>
			</pre>
		</div>

		Código que modifica uma coleção sobre a qual está iterando pode ser inseguro. No lugar disso, usualmente você deve iterar sobre uma cópia da coleção ou criar uma nova coleção:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				# Create a sample collection
				users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}

				# Strategy:  Iterate over a copy
				for user, status in users.copy().items():
				    if status == 'inactive':
				        del users[user]

				# Strategy:  Create a new collection
				active_users = {}
				for user, status in users.items():
				    if status == 'active':
				        active_users[user] = status	
				</code>
			</pre>
		</div>

		<h3 id="4.3">4.3. A função range()<a class="a-indice" href="#i-4.3"><sub>&nbsp;índice</sub></a></h3>
		Se você precisa iterar sobre sequências numéricas, a função embutida range() é a resposta. Ela gera progressões aritméticas:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> for i in range(5):
				...     print(i)
				...
				0
				1
				2
				3
				4	
				</code>
			</pre>
		</div>

		O ponto de parada fornecido nunca é incluído na lista; range(10) gera uma lista com 10 valores, exatamente os índices válidos para uma sequência de comprimento 10. É possível iniciar o intervalo com outro número, ou alterar a razão da progressão (inclusive com passo negativo):<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> list(range(5, 10))
				[5, 6, 7, 8, 9]

				>>> list(range(0, 10, 3))
				[0, 3, 6, 9]

				>>> list(range(-10, -100, -30))
				[-10, -40, -70]	
				</code>
			</pre>
		</div>

		Para iterar sobre os índices de uma sequência, combine range() e len() da seguinte forma:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
				>>> for i in range(len(a)):
				...     print(i, a[i])
				...
				0 Mary
				1 had
				2 a
				3 little
				4 lamb	
				</code>
			</pre>
		</div>

		Na maioria dos casos, porém, é mais conveniente usar a função enumerate(), veja Técnicas de iteração.<br><br>

		Uma coisa estranha acontece se você imprime um intervalo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> range(10)
				range(0, 10)	
				</code>
			</pre>
		</div>

		Em muitos aspectos, o objeto retornado pela função range() se comporta como se fosse uma lista, mas na verdade não é. É um objeto que retorna os itens sucessivos da sequência desejada quando você itera sobre a mesma, mas na verdade ele não gera a lista, economizando espaço.<br><br>

		Dizemos que um objeto é iterável, isso é, candidato a ser alvo de uma função ou construção que espera alguma coisa capaz de retornar sucessivamente seus elementos um de cada vez. Nós vimos que o comando for é um exemplo de construção, enquanto que um exemplo de função que recebe um iterável é sum():<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> sum(range(4))  # 0 + 1 + 2 + 3
				6	
				</code>
			</pre>
		</div>

		Mais tarde, veremos mais funções que retornam iteráveis e tomam iteráveis como argumentos. No capítulo Estruturas de dados, iremos discutir em mais detalhes sobre list().<br><br>

		<h3 id="4.4">4.4. Comandos break e continue, e cláusula else, nos laços de repetição<a class="a-indice" href="#i-4.4"><sub>&nbsp;índice</sub></a></h3>
		O comando break, como no C, sai imediatamente do laço de repetição mais interno, seja for ou while.<br><br>

		Laços podem ter uma cláusula else, que é executada sempre que o laço se encerra por exaustão do iterável (no caso do for) ou quando a condição se torna falsa (no caso do while), mas nunca quando o laço é interrompido por um break. Isto é exemplificado no próximo exemplo que procura números primos:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> for n in range(2, 10):
				...     for x in range(2, n):
				...         if n % x == 0:
				...             print(n, 'equals', x, '*', n//x)
				...             break
				...     else:
				...         # loop fell through without finding a factor
				...         print(n, 'is a prime number')
				...
				2 is a prime number
				3 is a prime number
				4 equals 2 * 2
				5 is a prime number
				6 equals 2 * 3
				7 is a prime number
				8 equals 2 * 4
				9 equals 3 * 3	
				</code>
			</pre>
		</div>

		(Sim, o código está correto. Olhe atentamente: a cláusula else pertence ao laço for, e não ao comando if.)<br><br>

		Quando usado em um laço, a cláusula else tem mais em comum com a cláusula else de um comando try do que com a de um comando if: a cláusula else de um comando try executa quando não ocorre exceção, e o else de um laço executa quando não ocorre um break. Para mais informações sobre comando try e exceções, veja Tratamento de exceções.<br><br>

		A instrução continue, também emprestada da linguagem C, continua com a próxima iteração do laço:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> for num in range(2, 10):
				...     if num % 2 == 0:
				...         print("Found an even number", num)
				...         continue
				...     print("Found an odd number", num)
				...
				Found an even number 2
				Found an odd number 3
				Found an even number 4
				Found an odd number 5
				Found an even number 6
				Found an odd number 7
				Found an even number 8
				Found an odd number 9	
				</code>
			</pre>
		</div>

		<h3 id="4.5">4.5. Comandos pass<a class="a-indice" href="#i-4.5"><sub>&nbsp;índice</sub></a></h3>
		O comando pass não faz nada. Pode ser usada quando a sintaxe exige um comando mas a semântica do programa não requer nenhuma ação. Por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> while True:
				...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
				...
				Isto é usado muitas vezes para se definir classes mínimas:

				>>>
				>>> class MyEmptyClass:
				...     pass
				...	
				</code>
			</pre>
		</div>

		Outra ocasião em que o pass pode ser usado é como um substituto temporário para uma função ou bloco condicional, quando se está trabalhando com código novo, ainda indefinido, permitindo que mantenha-se o pensamento num nível mais abstrato. O pass é silenciosamente ignorado:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def initlog(*args):
				...     pass   # Remember to implement this!
				...	
				</code>
			</pre>
		</div>

		<h3 id="4.6">4.6. Instruções match<a class="a-indice" href="#i-4.6"><sub>&nbsp;índice</sub></a></h3>
		Uma instrução de correspondência pega uma expressão e compara seu valor com padrões sucessivos fornecidos como um ou mais blocos de case. Isso é superficialmente semelhante a uma instrução switch em C, Java ou JavaScript (e muitas outras linguagens), mas também pode extrair componentes (elementos de sequência ou atributos de objeto) do valor em variáveis.<br><br>

		A forma mais simples compara um valor de assunto com um ou mais literais:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def http_error(status):
				    match status:
				        case 400:
				            return "Bad request"
				        case 404:
				            return "Not found"
				        case 418:
				            return "I'm a teapot"
				        case _:
				            return "Something's wrong with the internet"	
				</code>
			</pre>
		</div>

		Observe o último bloco: o “nome da variável” _ atua como um curinga e nunca falha em corresponder. Se nenhum caso corresponder, nenhuma das ramificações será executada.<br><br>

		Você pode combinar vários literais em um único padrão usando | (“ou”):<br><br>

		<div class="exemplo">
			<pre>
				<code>
				case 401 | 403 | 404:
				    return "Not allowed"	
				</code>
			</pre>
		</div>

		Os padrões podem se parecer com atribuições de desempacotamento e podem ser usados para vincular variáveis:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				# point is an (x, y) tuple
				match point:
				    case (0, 0):
				        print("Origin")
				    case (0, y):
				        print(f"Y={y}")
				    case (x, 0):
				        print(f"X={x}")
				    case (x, y):
				        print(f"X={x}, Y={y}")
				    case _:
				        raise ValueError("Not a point")	
				</code>
			</pre>
		</div>

		Estude isso com cuidado! O primeiro padrão tem dois literais e pode ser considerado uma extensão do padrão literal mostrado acima. Mas os próximos dois padrões combinam um literal e uma variável, e a variável vincula um valor do assunto (point). O quarto padrão captura dois valores, o que o torna conceitualmente semelhante à atribuição de desempacotamento (x, y) = point.<br><br>

		Se você estiver usando classes para estruturar seus dados, você pode usar o nome da classe seguido por uma lista de argumentos semelhante a um construtor, mas com a capacidade de capturar atributos em variáveis:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				class Point:
				    x: int
				    y: int

				def where_is(point):
				    match point:
				        case Point(x=0, y=0):
				            print("Origin")
				        case Point(x=0, y=y):
				            print(f"Y={y}")
				        case Point(x=x, y=0):
				            print(f"X={x}")
				        case Point():
				            print("Somewhere else")
				        case _:
				            print("Not a point")	
				</code>
			</pre>
		</div>

		Você pode usar parâmetros posicionais com algumas classes embutidas que fornecem uma ordem para seus atributos (por exemplo, classes de dados). Você também pode definir uma posição específica para atributos em padrões configurando o atributo especial __match_args__ em suas classes. Se for definido como (“x”, “y”), os seguintes padrões são todos equivalentes (e todos vinculam o atributo y à variável var):<br><br>

		<div class="exemplo">
			<pre>
				<code>
				Point(1, var)
				Point(1, y=var)
				Point(x=1, y=var)
				Point(y=var, x=1)	
				</code>
			</pre>
		</div>

		Uma maneira recomendada de ler padrões é vê-los como uma forma estendida do que você colocaria à esquerda de uma atribuição, para entender quais variáveis seriam definidas para quê. Apenas os nomes autônomos (como var acima) são atribuídos por uma instrução de correspondência. Nomes pontilhados (como foo.bar), nomes de atributos (o x= e y= acima) ou nomes de classes (reconhecidos pelo “(…)” próximo a eles, como Point acima) nunca são atribuídos.<br><br>

		Os padrões podem ser aninhados arbitrariamente. Por exemplo, se tivermos uma pequena lista de pontos, poderíamos correspondê-la assim:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				match points:
				    case []:
				        print("No points")
				    case [Point(0, 0)]:
				        print("The origin")
				    case [Point(x, y)]:
				        print(f"Single point {x}, {y}")
				    case [Point(0, y1), Point(0, y2)]:
				        print(f"Two on the Y axis at {y1}, {y2}")
				    case _:
				        print("Something else")	
				</code>
			</pre>
		</div>

		Podemos adicionar uma cláusula if a um padrão, conhecido como “guarda”. Se a guarda for falsa, match continua para tentar o próximo bloco de caso. Observe que a captura de valor ocorre antes que a guarda seja avaliada:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				match point:
				    case Point(x, y) if x == y:
				        print(f"Y=X at {x}")
				    case Point(x, y):
				        print(f"Not on the diagonal")	
				</code>
			</pre>
		</div>

		Vários outros recursos importantes desta instrução:<br><br>

		Assim como desempacotar atribuições, os padrões de tupla e lista têm exatamente o mesmo significado e realmente correspondem a sequências arbitrárias. Uma exceção importante é que eles não correspondem a iteradores ou strings.<br><br>

		Os padrões de sequência têm suporte ao desempacotamento estendido: [x, y, *rest] e (x, y, *rest) funcionam de forma semelhante ao desempacotamento de atribuições. O nome depois de * também pode ser _, então (x, y, *_) corresponde a uma sequência de pelo menos dois itens sem ligar os itens restantes.<br><br>

		Mapping patterns: {"bandwidth": b, "latency": l} captures the "bandwidth" and "latency" values from a dictionary. Unlike sequence patterns, extra keys are ignored. An unpacking like **rest is also supported. (But **_ would be redundant, so it is not allowed.)<br><br>

		Subpadrões podem ser capturados usando a palavra reservada as:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				case (Point(x1, y1), Point(x2, y2) as p2): ...	
				</code>
			</pre>
		</div>

		Vai capturar o segundo elemento da entrada como p2 (se a entrada for uma sequência de dois pontos)<br><br>

		A maioria dos literais são comparados por igualdade, no entando os singletons True, False e None são comparados por identidade.<br><br>

		Padrões podem usar constantes nomeadas. Estas devem ser nomes pontilhados para prevenir que sejam interpretadas como variáveis de captura:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				from enum import Enum
				class Color(Enum):
				    RED = 'red'
				    GREEN = 'green'
				    BLUE = 'blue'

				color = Color(input("Enter your choice of 'red', 'blue' or 'green': "))

				match color:
				    case Color.RED:
				        print("I see red!")
				    case Color.GREEN:
				        print("Grass is green")
				    case Color.BLUE:
				        print("I'm feeling the blues :(")	
				</code>
			</pre>
		</div>

		Para uma explicação mais detalhada e exemplos adicionais, você pode olhar PEP 636 que foi escrita em formato de tutorial.<br><br>

		<h3 id="4.7">4.7. Definindo funções<a class="a-indice" href="#i-4.7"><sub>&nbsp;índice</sub></a></h3>
		Podemos criar uma função que escreve a série de Fibonacci até um limite arbitrário:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def fib(n):    # write Fibonacci series up to n
				...     """Print a Fibonacci series up to n."""
				...     a, b = 0, 1
				...     while a < n:
				...         print(a, end=' ')
				...         a, b = b, a+b
				...     print()
				...
				>>> # Now call the function we just defined:
				... fib(2000)
				0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597	
				</code>
			</pre>
		</div>

		A palavra reservada def inicia a definição de uma função. Ela deve ser seguida do nome da função e da lista de parâmetros formais entre parênteses. Os comandos que formam o corpo da função começam na linha seguinte e devem ser indentados.<br><br>

		Opcionalmente, a primeira linha do corpo da função pode ser uma literal string, cujo propósito é documentar a função. Se presente, essa string chama-se docstring. (Há mais informação sobre docstrings na seção Strings de documentação.) Existem ferramentas que utilizam docstrings para produzir automaticamente documentação online ou para imprimir, ou ainda, permitir que o usuário navegue interativamente pelo código. É uma boa prática incluir sempre docstrings em suas funções, portanto, tente fazer disso um hábito.<br><br>

		A execução de uma função cria uma nova tabela de símbolos para as variáveis locais da função. Mais precisamente, todas as atribuições de variáveis numa função são armazenadas na tabela de símbolos local; referências a variáveis são buscadas primeiro na tabela de símbolos local, em seguida na tabela de símbolos locais de funções delimitadoras ou circundantes, depois na tabela de símbolos global e, finalmente, na tabela de nomes da própria linguagem. Embora possam ser referenciadas, variáveis globais e de funções externas não podem ter atribuições (a menos que seja utilizado o comando global, para variáveis globais, ou nonlocal, para variáveis de funções externas).<br><br>

		Os parâmetros reais (argumentos) de uma chamada de função são introduzidos na tabela de símbolos local da função no momento da chamada; portanto, argumentos são passados por valor (onde o valor é sempre uma referência para objeto, não o valor do objeto). 1 Quando uma função chama outra função, ou chama a si mesma recursivamente, uma nova tabela de símbolos é criada para tal chamada.<br><br>

		Uma definição de função associa o nome da função com o objeto função na tabela de símbolos atual. O interpretador reconhece o objeto apontado pelo nome como uma função definida pelo usuário. Outros nomes também podem apontar para o mesmo objeto função e também pode ser usados pra acessar a função:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> fib
				<function fib at 10042ed0>
				>>> f = fib
				>>> f(100)
				0 1 1 2 3 5 8 13 21 34 55 89	
				</code>
			</pre>
		</div>

		Conhecendo outras linguagens, pode-se questionar que fib não é uma função, mas um procedimento, pois ela não devolve um valor. Na verdade, mesmo funções que não usam o comando return devolvem um valor, ainda que pouco interessante. Esse valor é chamado None (é um nome embutido). O interpretador interativo evita escrever None quando ele é o único resultado de uma expressão. Mas se quiser vê-lo pode usar a função print():<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> fib(0)
				>>> print(fib(0))
				None	
				</code>
			</pre>
		</div>

		É fácil escrever uma função que retorna uma lista de números da série de Fibonacci, ao invés de exibi-los:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def fib2(n):  # return Fibonacci series up to n
				...     """Return a list containing the Fibonacci series up to n."""
				...     result = []
				...     a, b = 0, 1
				...     while a < n:
				...         result.append(a)    # see below
				...         a, b = b, a+b
				...     return result
				...
				>>> f100 = fib2(100)    # call it
				>>> f100                # write the result
				[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]	
				</code>
			</pre>
		</div>

		Este exemplo demonstra novos recursos de Python:<br><br>

		A instrução return finaliza a execução e retorna um valor da função. return sem qualquer expressão como argumento retorna None. Atingir o final da função também retorna None.<br><br>

		A instrução result.append(a) chama um método do objeto lista result. Um método é uma função que ‘pertence’ a um objeto, e é chamada obj.nomemetodo, onde obj é um objeto qualquer (pode ser uma expressão), e nomemetodo é o nome de um método que foi definido pelo tipo do objeto. Tipos diferentes definem métodos diferentes. Métodos de diferentes tipos podem ter o mesmo nome sem ambiguidade. (É possível definir seus próprios tipos de objetos e métodos, utilizando classes, veja em Classes) O método append(), mostrado no exemplo é definido para objetos do tipo lista; adiciona um novo elemento ao final da lista. Neste exemplo, ele equivale a result = result + [a], só que mais eficiente.<br><br>

		<h3 id="4.8">4.8. Mais sobre definição de funções<a class="a-indice" href="#i-4.8"><sub>&nbsp;índice</sub></a></h3>
		É possível definir funções com um número variável de argumentos. Existem três formas, que podem ser combinadas.<br><br>

		<h3 id="4.8.1">4.8.1. Argumentos com valor padrão<a class="a-indice" href="#i-4.8.1"><sub>&nbsp;índice</sub></a></h3>
		A mais útil das três é especificar um valor padrão para um ou mais argumentos. Isso cria uma função que pode ser invocada com menos argumentos do que os que foram definidos. Por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def ask_ok(prompt, retries=4, reminder='Please try again!'):
				    while True:
				        ok = input(prompt)
				        if ok in ('y', 'ye', 'yes'):
				            return True
				        if ok in ('n', 'no', 'nop', 'nope'):
				            return False
				        retries = retries - 1
				        if retries < 0:
				            raise ValueError('invalid user response')
				        print(reminder)	
				</code>
			</pre>
		</div>

		Essa função pode ser chamada de várias formas:<br><br>

		fornecendo apenas o argumento obrigatório: ask_ok('Do you really want to quit?')<br><br>

		fornecendo um dos argumentos opcionais: ask_ok('OK to overwrite the file?', 2)<br><br>

		ou fornecendo todos os argumentos: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')<br><br>

		Este exemplo também introduz a palavra-chave in, que verifica se uma sequência contém ou não um determinado valor.<br><br>

		Os valores padrões são avaliados no momento da definição da função, e no escopo em que a função foi definida, portanto:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				i = 5

				def f(arg=i):
				    print(arg)

				i = 6
				f()
				irá exibir 5.	
				</code>
			</pre>
		</div>

		Aviso importante: Valores padrões são avaliados apenas uma vez. Isso faz diferença quando o valor é um objeto mutável, como uma lista, dicionário, ou instâncias de classes. Por exemplo, a função a seguir acumula os argumentos passados, nas chamadas subsequentes:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def f(a, L=[]):
				    L.append(a)
				    return L

				print(f(1))
				print(f(2))
				print(f(3))
				Isso exibirá:

				[1]
				[1, 2]
				[1, 2, 3]	
				</code>
			</pre>
		</div>

		Se não quiser que o valor padrão seja compartilhado entre chamadas subsequentes, pode reescrever a função assim:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def f(a, L=None):
				    if L is None:
				        L = []
				    L.append(a)
				    return L	
				</code>
			</pre>
		</div>

		<h3 id="4.8.2">4.8.2. Argumentos nomeados<a class="a-indice" href="#i-4.8.2"><sub>&nbsp;índice</sub></a></h3>
		Funções também podem ser chamadas usando argumentos nomeados da forma chave=valor. Por exemplo, a função a seguir:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
				    print("-- This parrot wouldn't", action, end=' ')
				    print("if you put", voltage, "volts through it.")
				    print("-- Lovely plumage, the", type)
				    print("-- It's", state, "!")	
				</code>
			</pre>
		</div>				    

		aceita um argumento obrigatório (voltage) e três argumentos opcionais (state, action, e type). Esta função pode ser chamada de qualquer uma dessas formas:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				parrot(1000)                                          # 1 positional argument
				parrot(voltage=1000)                                  # 1 keyword argument
				parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
				parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
				parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
				parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword	
				</code>
			</pre>
		</div>

		mas todas as formas a seguir seriam inválidas:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				parrot()                     # required argument missing
				parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument
				parrot(110, voltage=220)     # duplicate value for the same argument
				parrot(actor='John Cleese')  # unknown keyword argument	
				</code>
			</pre>
		</div>

		Em uma chamada de função, argumentos nomeados devem vir depois dos argumentos posicionais. Todos os argumentos nomeados passados devem corresponder com argumentos aceitos pela função (ex. actor não é um argumento nomeado válido para a função parrot), mas sua ordem é irrelevante. Isto também inclui argumentos obrigatórios (ex.: parrot(voltage=1000) funciona). Nenhum argumento pode receber mais de um valor. Eis um exemplo que não funciona devido a esta restrição:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def function(a):
				...     pass
				...
				>>> function(0, a=0)
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: function() got multiple values for argument 'a'	
				</code>
			</pre>
		</div>

		Quando um último parâmetro formal no formato **nome está presente, ele recebe um dicionário (veja Tipo mapeamento — dict) contendo todos os argumentos nomeados, exceto aqueles que correspondem a um parâmetro formal. Isto pode ser combinado com um parâmetro formal no formato *nome (descrito na próxima subseção) que recebe uma tupla contendo os argumentos posicionais, além da lista de parâmetros formais. (*nome deve ocorrer antes de **nome.) Por exemplo, se definirmos uma função assim:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def cheeseshop(kind, *arguments, **keywords):
				    print("-- Do you have any", kind, "?")
				    print("-- I'm sorry, we're all out of", kind)
				    for arg in arguments:
				        print(arg)
				    print("-" * 40)
				    for kw in keywords:
				        print(kw, ":", keywords[kw])	
				</code>
			</pre>
		</div>

		Pode ser chamada assim:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				cheeseshop("Limburger", "It's very runny, sir.",
				           "It's really very, VERY runny, sir.",
				           shopkeeper="Michael Palin",
				           client="John Cleese",
				           sketch="Cheese Shop Sketch")	
				</code>
			</pre>
		</div>

		e, claro, exibiria:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				-- Do you have any Limburger ?
				-- I'm sorry, we're all out of Limburger
				It's very runny, sir.
				It's really very, VERY runny, sir.
				----------------------------------------
				shopkeeper : Michael Palin
				client : John Cleese
				sketch : Cheese Shop Sketch	
				</code>
			</pre>
		</div>

		Observe que a ordem em que os argumentos nomeados são exibidos é garantida para corresponder à ordem em que foram fornecidos na chamada da função.<br><br>

		<h3 id="4.8.3">4.8.3. Parâmetros especiais<a class="a-indice" href="#i-4.8.3"><sub>&nbsp;índice</sub></a></h3>
		Por padrão, argumentos podem ser passadas para uma função Python tanto por posição quanto explicitamente pelo nome. Para uma melhor legibilidade e desempenho, faz sentido restringir a maneira pelo qual argumentos possam ser passados, assim um desenvolvedor precisa apenas olhar para a definição da função para determinar se os itens são passados por posição, por posição e nome, ou por nome.<br><br>

		<div class="exemplo">
			<pre>
				<code>
				A definição de uma função pode parecer com:<br><br>

				def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
				      -----------    ----------     ----------
				        |             |                  |
				        |        Positional or keyword   |
				        |                                - Keyword only
				         -- Positional only	
				</code>
			</pre>
		</div>

		onde / e * são opcionais. Se usados, esses símbolos indicam o tipo de parâmetro pelo qual os argumentos podem ser passados para as funções: somente-posicional, posicional-ou-nomeado, e somente-nomeado. Parâmetros nomeados são também conhecidos como parâmetros palavra-chave.<br><br>

		<h3 id="4.8.3.1">4.8.3.1. Argumentos posicional-ou-nomeados<a class="a-indice" href="#i-4.8.3.1"><sub>&nbsp;índice</sub></a></h3>
		Se / e * não estão presentes na definição da função, argumentos podem ser passados para uma função por posição ou por nome.<br><br>

		<h3 id="4.8.3.2">4.8.3.2. Parâmetros somente-posicionais<a class="a-indice" href="#i-4.8.3.2"><sub>&nbsp;índice</sub></a></h3>
		Olhando com um pouco mais de detalhes, é possível definir certos parâmetros como somente-posicional. Se somente-posicional, a ordem do parâmetro importa, e os parâmetros não podem ser passados por nome. Parâmetros somente-posicional são colocados antes de / (barra). A / é usada para logicamente separar os argumentos somente-posicional dos demais parâmetros. Se não existe uma / na definição da função, não existe parâmetros somente-posicionais.<br><br>

		Parâmetros após a / podem ser posicional-ou-nomeado ou somente-nomeado.<br><br>

		<h3 id="4.8.3.3">4.8.3.3. Argumentos somente-nomeados<a class="a-indice" href="#i-4.8.3.3"><sub>&nbsp;índice</sub></a></h3>
		Para definir parâmetros como somente-nomeado, indicando que o parâmetro deve ser passado por argumento nomeado, colocamos um * na lista de argumentos imediatamente antes do primeiro parâmetro somente-nomeado.<br><br>

		<h3 id="4.8.3.4">4.8.3.4. Exemplos de funções<a class="a-indice" href="#i-4.8.3.4"><sub>&nbsp;índice</sub></a></h3>
		Considere o seguinte exemplo de definição de função com atenção redobrada para os marcadores / e *:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def standard_arg(arg):
				...     print(arg)
				...
				>>> def pos_only_arg(arg, /):
				...     print(arg)
				...
				>>> def kwd_only_arg(*, arg):
				...     print(arg)
				...
				>>> def combined_example(pos_only, /, standard, *, kwd_only):
				...     print(pos_only, standard, kwd_only)	
				</code>
			</pre>
		</div>

		A definição da primeira função, standard_arg, a forma mais familiar, não coloca nenhuma restrição para a chamada da função e argumentos podem ser passados por posição ou nome:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> standard_arg(2)
				2

				>>> standard_arg(arg=2)
				2	
				</code>
			</pre>
		</div>

		A segunda função pos_only_arg está restrita ao uso de parâmetros somente posicionais, uma vez que existe uma / na definição da função:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> pos_only_arg(1)
				1

				>>> pos_only_arg(arg=1)
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'	
				</code>
			</pre>
		</div>

		A terceira função kwd_only_args permite somente argumentos nomeados como indicado pelo * na definição da função:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> kwd_only_arg(3)
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given

				>>> kwd_only_arg(arg=3)
				3	
				</code>
			</pre>
		</div>

		E a última usa as três convenções de chamada na mesma definição de função:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> combined_example(1, 2, 3)
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: combined_example() takes 2 positional arguments but 3 were given

				>>> combined_example(1, 2, kwd_only=3)
				1 2 3

				>>> combined_example(1, standard=2, kwd_only=3)
				1 2 3

				>>> combined_example(pos_only=1, standard=2, kwd_only=3)
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'	
				</code>
			</pre>
		</div>

		Finalmente, considere essa definição de função que possui uma potencial colisão entre o argumento posicional name e **kwds que possui name como uma chave:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def foo(name, **kwds):
				    return 'name' in kwds	
				</code>
			</pre>
		</div>

		Não é possível essa chamada devolver True, uma vez que a chave 'name' sempre será aplicada para o primeiro parâmetro. Por exemplo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> foo(1, **{'name': 2})
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: foo() got multiple values for argument 'name'
				>>>	
				</code>
			</pre>
		</div>

		Mas usando / (somente argumentos posicionais), isso é possível já que permite name como um argumento posicional e 'name' como uma chave nos argumentos nomeados:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def foo(name, /, **kwds):
				    return 'name' in kwds
				>>> foo(1, **{'name': 2})
				True	
				</code>
			</pre>
		</div>

		Em outras palavras, o nome de parâmetros somente-posicional podem ser usados em **kwds sem ambiguidade.<br><br>

		<h3 id="4.8.3.5">4.8.3.5. Recapitulando<a class="a-indice" href="#i-4.8.3.5"><sub>&nbsp;índice</sub></a></h3>
		A situação irá determinar quais parâmetros usar na definição da função:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):	
				</code>
			</pre>
		</div>

		Como guia:<br>

		Use somente-posicional se você não quer que o nome do parâmetro esteja disponível para o usuário. Isso é útil quando nomes de parâmetros não tem um significado real, se você quer forçar a ordem dos argumentos da função quando ela é chamada ou se você precisa ter alguns parâmetros posicionais e alguns nomeados.<br><br>

		Use somente-nomeado quando os nomes tem significado e a definição da função fica mais clara deixando esses nomes explícitos ou se você quer evitar que usuários confiem na posição dos argumentos que estão sendo passados.<br><br>

		Para uma API, use somente-posicional para evitar quebras na mudança da API se os nomes dos parâmetros forem alterados no futuro.<br><br>

		<h3 id="4.8.4">4.8.4. Listas de argumentos arbitrárias<a class="a-indice" href="#i-4.8.4"><sub>&nbsp;índice</sub></a></h3>
		Finalmente, a opção menos usada é especificar que a função pode ser chamada com um número arbitrário de argumentos. Esses argumentos serão empacotados em uma tupla (ver Tuplas e Sequências). Antes dos argumentos em número variável, zero ou mais argumentos normais podem estar presentes.<br><br>

		<div class="exemplo">
			<pre>
				<code>
				def write_multiple_items(file, separator, *args):
				    file.write(separator.join(args))	
				</code>
			</pre>
		</div>

		Normalmente, esses argumentos variádicos estarão no final da lista de parâmetros formais, porque eles englobam todos os argumentos de entrada restantes, que são passados para a função. Quaisquer parâmetros formais que ocorrem após o parâmetro *args são argumentos ‘somente-nomeados’ , o que significa que eles só podem ser usados como chave-valor, em vez de argumentos posicionais:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def concat(*args, sep="/"):
				...     return sep.join(args)
				...
				>>> concat("earth", "mars", "venus")
				'earth/mars/venus'
				>>> concat("earth", "mars", "venus", sep=".")
				'earth.mars.venus'	
				</code>
			</pre>
		</div>

		<h3 id="4.8.5">4.8.5. Desempacotando listas de argumentos<a class="a-indice" href="#i-4.8.5"><sub>&nbsp;índice</sub></a></h3>
		A situação inversa ocorre quando os argumentos já estão numa lista ou tupla mas ela precisa ser explodida para invocarmos uma função que requer argumentos posicionais separados. Por exemplo, a função range() espera argumentos separados, start e stop. Se os valores já estiverem juntos em uma lista ou tupla, escreva a chamada de função com o operador * para desempacotá-los da sequência:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> list(range(3, 6))            # normal call with separate arguments
				[3, 4, 5]
				>>> args = [3, 6]
				>>> list(range(*args))            # call with arguments unpacked from a list
				[3, 4, 5]	
				</code>
			</pre>
		</div>

		Da mesma forma, dicionários podem produzir argumentos nomeados com o operador **:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def parrot(voltage, state='a stiff', action='voom'):
				...     print("-- This parrot wouldn't", action, end=' ')
				...     print("if you put", voltage, "volts through it.", end=' ')
				...     print("E's", state, "!")
				...
				>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
				>>> parrot(**d)
				-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !	
				</code>
			</pre>
		</div>

		<h3 id="4.8.6">4.8.6. Expressões lambda<a class="a-indice" href="#i-4.8.6"><sub>&nbsp;índice</sub></a></h3>
		Pequenas funções anônimas podem ser criadas com a palavra-chave lambda. Esta função retorna a soma de seus dois argumentos: lambda a, b: a+b. As funções lambda podem ser usadas sempre que objetos função forem necessários. Eles são sintaticamente restritos a uma única expressão. Semanticamente, eles são apenas açúcar sintático para uma definição de função normal. Como definições de funções aninhadas, as funções lambda podem referenciar variáveis contidas no escopo:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def make_incrementor(n):
				...     return lambda x: x + n
				...
				>>> f = make_incrementor(42)
				>>> f(0)
				42
				>>> f(1)
				43	
				</code>
			</pre>
		</div>

		O exemplo acima usa uma expressão lambda para retornar uma função. Outro uso é passar uma pequena função como um argumento:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
				>>> pairs.sort(key=lambda pair: pair[1])
				>>> pairs
				[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]	
				</code>
			</pre>
		</div>

		<h3 id="4.8.7">4.8.7. Strings de documentação<a class="a-indice" href="#i-4.8.7"><sub>&nbsp;índice</sub></a></h3>
		Aqui estão algumas convenções sobre o conteúdo e formatação de strings de documentação, também conhecidas como docstrings.<br><br>

		A primeira linha deve sempre ser curta, um resumo conciso do propósito do objeto. Por brevidade, não deve explicitamente se referir ao nome ou tipo do objeto, uma vez que estas informações estão disponíveis por outros meios (exceto se o nome da função for o próprio verbo que descreve a finalidade da função). Essa linha deve começar com letra maiúscula e terminar com ponto.<br><br>

		Se existem mais linhas na string de documentação, a segunda linha deve estar em branco, separando visualmente o resumo do resto da descrição. As linhas seguintes devem conter um ou mais parágrafos descrevendo as convenções de chamada ao objeto, seus efeitos colaterais, etc.<br><br>

		O analisador Python não remove a indentação de literais string multilinha. Portanto, ferramentas que processem strings de documentação precisam lidar com isso, quando desejável. Existe uma convenção para isso. A primeira linha não vazia após a linha de sumário determina a indentação para o resto da string de documentação. (Não podemos usar a primeira linha para isso porque ela em geral está adjacente às aspas que iniciam a string, portanto sua indentação real não fica aparente.) Espaços em branco “equivalentes” a essa indentação são então removidos do início das demais linhas da string. Linhas com indentação menor não devem ocorrer, mas se ocorrerem, todos os espaços à sua esquerda são removidos. A equivalência de espaços em branco deve ser testada após a expansão das tabulações (8 espaços, normalmente).<br><br>

		Eis um exemplo de uma string de documentação multilinha:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def my_function():
				...     """Do nothing, but document it.
				...
				...     No, really, it doesn't do anything.
				...     """
				...     pass
				...
				>>> print(my_function.__doc__)

				Do nothing, but document it.

				    No, really, it doesn't do anything.	
				</code>
			</pre>
		</div>

		<h3 id="4.8.8">4.8.8. Anotações de função<a class="a-indice" href="#i-4.8.8"><sub>&nbsp;índice</sub></a></h3>
		Anotações de função são informações de metadados completamente opcionais sobre os tipos usados pelas funções definidas pelo usuário (veja PEP 3107 e PEP 484 para mais informações).<br><br>

		Anotações são armazenadas no atributo __annotations__ da função como um dicionário e não tem nenhum efeito em qualquer outra parte da função. Anotações de parâmetro são definidas por dois-pontos (:`)  após o nome do parâmetro, seguida por uma expressão que quando avaliada determina o valor da anotação. Anotações do tipo do retorno são definidas por um literal ``->, seguida por uma expressão, entre a lista de parâmetro e os dois-pontos que marcam o fim da instrução def . O exemplo a seguir possui um argumento obrigatório, um argumento opcional e o valor de retorno anotados:<br><br>

		<div class="exemplo">
			<pre>
				<code>
				>>>
				>>> def f(ham: str, eggs: str = 'eggs') -> str:
				...     print("Annotations:", f.__annotations__)
				...     print("Arguments:", ham, eggs)
				...     return ham + ' and ' + eggs
				...
				>>> f('spam')
				Annotations: {'ham': &lt;class 'str'&gt;, 'return': &lt;class 'str'&gt;, 'eggs': &lt;class 'str'&gt;}
				Arguments: spam eggs
				'spam and eggs'	
				</code>
			</pre>
		</div>

		<h3 id="4.9">4.9. Intermezzo: estilo de codificação<a class="a-indice" href="#i-4.9"><sub>&nbsp;índice</sub></a></h3>
		Agora que está prestes a escrever códigos mais longos e complexos em Python, é um bom momento para falar sobre estilo de codificação. A maioria das linguagens podem ser escritas (ou formatadas) em diferentes estilos; alguns são mais legíveis do que outros. Tornar o seu código mais fácil de ler, para os outros, é sempre uma boa ideia, e adotar um estilo de codificação agradável ajuda bastante.<br><br>

		Em Python, a PEP 8 tornou-se o guia de estilo adotado pela maioria dos projetos; promove um estilo de codificação muito legível e visualmente agradável. Todo desenvolvedor Python deve lê-lo em algum momento; eis os pontos mais importantes, selecionados para você:<br><br>

		Use indentação com 4 espaços, e não use tabulações.<br><br>

		4 espaços são um bom meio termo entre indentação estreita (permite maior profundidade de aninhamento) e indentação larga (mais fácil de ler). Tabulações trazem complicações, e o melhor é não usar.<br><br>

		Quebre as linhas de modo que não excedam 79 caracteres.<br><br>

		Isso ajuda os usuários com telas pequenas e torna possível abrir vários arquivos de código lado a lado em telas maiores.<br><br>

		Deixe linhas em branco para separar funções e classes, e blocos de código dentro de funções.<br><br>

		Quando possível, coloque comentários em uma linha própria.<br><br>

		Escreva strings de documentação.<br><br>

		Use espaços ao redor de operadores e após vírgulas, mas não diretamente dentro de parênteses, colchetes e chaves: a = f(1, 2) + g(3, 4).<br><br>

		Nomeie suas classes e funções de forma consistente; a convenção é usar MaiusculoCamelCase para classes e minusculo_com_sublinhado para funções e métodos. Sempre use self como o nome para o primeiro argumento dos métodos (veja Uma primeira olhada nas classes para mais informações sobre classes e métodos).<br><br>

		Não use codificações exóticas se o seu código é feito para ser usado em um contexto internacional. O padrão do Python, UTF-8, ou mesmo ASCII puro funciona bem em qualquer caso.<br><br>

		Da mesma forma, não use caracteres não-ASCII em identificadores se houver apenas a menor chance de pessoas falando um idioma diferente ler ou manter o código.<br><br>

		<blockquote>
		Notas de rodapé<br>
		1 Na verdade, passagem por referência para objeto seria uma descrição melhor, pois, se um objeto mutável for passado, quem chamou verá as alterações feitas por quem foi chamado (por exemplo, a inclusão de itens em uma lista).
		</blockquote>
		
		<h2 id="5">5. Estruturas de dados<a class="a-indice" href="#i-5"><sub>&nbsp;índice</sub></a></h2>
		<p>Esse capítulo descreve algumas coisas que você já aprendeu em detalhes e adiciona algumas coisas novas também.</p>

		<h3 id="5.1">5.1. Mais sobre listas<a class="a-indice" href="#i-5.1"><sub>&nbsp;índice</sub></a></h3>
		<p>O tipo de dado lista tem ainda mais métodos. Aqui estão apresentados todos os métodos de objetos do tipo lista:</p>

		<code class="p-code">list.<strong>append</strong>(x)</code>
		<p>Adiciona um item ao fim da lista. Equivalente a <code class="p-code">a[len(a):] = [x]</code>.</p>

		<code class="p-code">list.<strong>extend</strong>(iterable)</code>
		<p>Prolonga a lista, adicionando no fim todos os elementos do argumento iterable passado como parâmetro. Equivalente a <code class="p-code">a[len(a):] = iterable</code>.</p>

		<code class="p-code">list.<strong>insert</strong>(i, x)</code>
		<p>Insere um item em uma dada posição. O primeiro argumento é o índice do elemento antes do qual será feita a inserção, assim <code class="p-code">a.insert(0, x)</code> insere um elemento na frente da lista e <code class="p-code">a.insert(len(a), x)</code> e equivale a <code class="p-code">a.append(x)</code>.</p>

		<code class="p-code">list.<strong>remove</strong>(x)</code>
		<p>Remove o primeiro item encontrado na lista cujo valor é igual a x. Se não existir valor igual, uma exceção <code class="p-code">ValueError</code> é levantada.</p>

		<code class="p-code">list.<strong>pop</strong>([i])</code>
		<p>Remove um item em uma dada posição na lista e o retorna. Se nenhum índice é especificado, <code class="p-code">a.pop()</code> remove e devolve o último item da lista. (Os colchetes ao redor do i na demonstração do método indica que o parâmetro é opcional, e não que é necessário escrever estes colchetes ao chamar o método. Você verá este tipo de notação frequentemente na Biblioteca de Referência Python.)</p>

		<code class="p-code">list.<strong>clear</strong>()</code>
		<p>Remove todos os itens de uma lista. Equivalente a <code class="p-code">del a[:]</code>.</p>

		<code class="p-code">list.<strong>index</strong>(x[, start[, end]])</code>
		<p>Devolve o índice base-zero do primeiro item cujo valor é igual a x, levantando <code class="p-code">ValueError</code> se este valor não existe.</p>

		<p>Os argumentos opcionais start e end são interpretados como nas notações de fatiamento e são usados para limitar a busca para uma subsequência específica da lista. O índice retornado é calculado relativo ao começo da sequência inteira e não referente ao argumento start.</p>

		<code class="p-code">list.<strong>count</strong>(x)</code>
		<p>Devolve o número de vezes em que x aparece na lista.</p>

		<code class="p-code">list.<strong>sort</strong>(*, key=None, reverse=False)</code>
		<p>Ordena os itens na lista (os argumentos podem ser usados para personalizar a ordenação, veja a função <code class="p-code">sorted()</code> para maiores explicações).</p>

		<code class="p-code">list.<strong>reverse</strong>()</code>
		<p>Inverte a ordem dos elementos na lista.</p>

		<code class="p-code">list.<strong>copy</strong>()</code>
		<p>Devolve uma cópia rasa da lista. Equivalente a <code class="p-code">a[:]</code>.</p>

		<p>Um exemplo que usa a maior parte dos métodos das listas:</p>
		<div class="exemplo">
			<pre>
				<code>
				>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
				>>> fruits.count('apple')
				2
				>>> fruits.count('tangerine')
				0
				>>> fruits.index('banana')
				3
				>>> fruits.index('banana', 4)  # Find next banana starting a position 4
				6
				>>> fruits.reverse()
				>>> fruits
				['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
				>>> fruits.append('grape')
				>>> fruits
				['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
				>>> fruits.sort()
				>>> fruits
				['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
				>>> fruits.pop()
				'pear'	
				</code>
			</pre>
		</div>
		<p>Você pode ter percebido que métodos como <code class="p-code">insert, remove</code> ou <code class="p-code">sort</code>, que apenas modificam a lista, não têm valor de retorno impresso – eles retornam o <code class="p-code">None</code> padrão. 1 Isto é um princípio de design para todas as estruturas de dados mutáveis em Python.</p>

		<p>Outra coisa que você deve estar atento é que nem todos os dados podem ser ordenados ou comparados. Por exemplo, , <code class="p-code">[None, 'hello', 10]</code> não podem ser ordenados, pois inteiros não podem ser comparados a strings e None não pode ser comparado a nenhum outro tipo. Além disso, existem alguns tipos de dados que não possuem uma relação de ordem definida. Por exemplo, <code class="p-code">3+4j < 5+7j</code> não é uma comparação válida.</p>

		<h3 id="5.1.1">5.1.1. Usando listas como pilhas<a class="a-indice" href="#i-5.1.1"><sub>&nbsp;índice</sub></a></h3>
		<p>Os métodos de lista tornam muito fácil utilizar listas como pilhas, onde o item adicionado por último é o primeiro a ser recuperado (política “último a entrar, primeiro a sair”). Para adicionar um item ao topo da pilha, use <code class="p-code">append()</code>. Para recuperar um item do topo da pilha use <code class="p-code">pop()</code> sem nenhum índice. Por exemplo:</p>

		<h3 id="5.1.2">5.1.2. Usando listas como filas<a class="a-indice" href="#i-5.1.2"><sub>&nbsp;índice</sub></a></h3>
		<p>Você também pode usar uma lista como uma fila, onde o primeiro item adicionado é o primeiro a ser recuperado (política “primeiro a entrar, primeiro a sair”); porém, listas não são eficientes para esta finalidade. Embora appends e pops no final da lista sejam rápidos, fazer inserts ou pops no início da lista é lento (porque todos os demais elementos têm que ser deslocados).</p>

		<p>Para implementar uma fila, use a classe collections.deque que foi projetada para permitir appends e pops eficientes nas duas extremidades. Por exemplo:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> from collections import deque
				>>> queue = deque(["Eric", "John", "Michael"])
				>>> queue.append("Terry")           # Terry arrives
				>>> queue.append("Graham")          # Graham arrives
				>>> queue.popleft()                 # The first to arrive now leaves
				'Eric'
				>>> queue.popleft()                 # The second to arrive now leaves
				'John'
				>>> queue                           # Remaining queue in order of arrival
				deque(['Michael', 'Terry', 'Graham'])
				</code>
			</pre>
		</div>

		<h3 id="5.1.3">5.1.3. Compreensões de lista<a class="a-indice" href="#i-5.1.3"><sub>&nbsp;índice</sub></a></h3>
		<p>Compreensões de lista fornece uma maneira concisa de criar uma lista. Aplicações comuns são criar novas listas onde cada elemento é o resultado de alguma operação aplicada a cada elemento de outra sequência ou iterável, ou criar uma subsequência de elementos que satisfaçam uma certa condição. (N.d.T. o termo original em inglês é list comprehensions, muito utilizado no Brasil; também se usa a abreviação listcomp).</p>

		<p>Por exemplo, suponha que queremos criar uma lista de quadrados, assim:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> squares = []
				>>> for x in range(10):
				...     squares.append(x**2)
				...
				>>> squares
				[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
				</code>
			</pre>
		</div>

		<p>Note que isto cria (ou sobrescreve) uma variável chamada x que ainda existe após o término do laço. Podemos calcular a lista dos quadrados sem qualquer efeito colateral usando:</p>

		<div class="exemplo">
			<pre>
				<code>
				squares = list(map(lambda x: x**2, range(10)))	
				</code>
			</pre>
		</div>

		<p>ou, de maneira equivalente:</p>

		<div class="exemplo">
			<pre>
				<code>
				squares = [x**2 for x in range(10)]
				</code>
			</pre>
		</div>

		<p>que é mais conciso e legível.</p>

		<p>Um compreensão de lista consiste de um par de colchetes contendo uma expressão seguida de uma cláusula for, e então zero ou mais cláusulas for ou if. O resultado será uma nova lista resultante da avaliação da expressão no contexto das cláusulas for e if. Por exemplo, essa compreensão combina os elementos de duas listas se eles forem diferentes:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
				[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]	
				</code>
			</pre>
		</div>

		<p>e é equivalente a:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> combs = []
				>>> for x in [1,2,3]:
				...     for y in [3,1,4]:
				...         if x != y:
				...             combs.append((x, y))
				...
				>>> combs
				[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
				</code>
			</pre>
		</div>

		<p>Note como a ordem das instruções <code class="p-code">for</code> e <code class="p-code">if</code> é a mesma em ambos os trechos.</p>

		<p>Se a expressão é uma tupla (ex., <code class="p-code">(x, y)</code> no exemplo anterior), ela deve ser inserida entre parênteses.</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> vec = [-4, -2, 0, 2, 4]
				>>> # create a new list with the values doubled
				>>> [x*2 for x in vec]
				[-8, -4, 0, 4, 8]
				>>> # filter the list to exclude negative numbers
				>>> [x for x in vec if x >= 0]
				[0, 2, 4]
				>>> # apply a function to all the elements
				>>> [abs(x) for x in vec]
				[4, 2, 0, 2, 4]
				>>> # call a method on each element
				>>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
				>>> [weapon.strip() for weapon in freshfruit]
				['banana', 'loganberry', 'passion fruit']
				>>> # create a list of 2-tuples like (number, square)
				>>> [(x, x**2) for x in range(6)]
				[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
				>>> # the tuple must be parenthesized, otherwise an error is raised
				>>> [x, x**2 for x in range(6)]
				  File "<stdin>", line 1, in <module>
				    [x, x**2 for x in range(6)]
				               ^
				SyntaxError: invalid syntax
				>>> # flatten a list using a listcomp with two 'for'
				>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
				>>> [num for elem in vec for num in elem]
				[1, 2, 3, 4, 5, 6, 7, 8, 9]
				</code>
			</pre>
		</div>

		<p>Compreensões de lista podem conter expressões complexas e funções aninhadas:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> from math import pi
				>>> [str(round(pi, i)) for i in range(1, 6)]
				['3.1', '3.14', '3.142', '3.1416', '3.14159']
				</code>
			</pre>
		</div>

		<h3 id="5.1.4">5.1.4. Compreensões de lista aninhadas<a class="a-indice" href="#i-5.1.4"><sub>&nbsp;índice</sub></a></h3>
		<p>A expressão inicial em uma compreensão de lista pode ser qualquer expressão arbitrária, incluindo outra compreensão de lista.</p>

		<p>Observe este exemplo de uma matriz 3x4 implementada como uma lista de 3 listas de comprimento 4:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> matrix = [
				...     [1, 2, 3, 4],
				...     [5, 6, 7, 8],
				...     [9, 10, 11, 12],
				... ]
				</code>
			</pre>
		</div>

		<p>A compreensão de lista abaixo transpõe as linhas e colunas:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> [[row[i] for row in matrix] for i in range(4)]
				[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
				</code>
			</pre>
		</div>

		<p>Como vimos na seção anterior, a compreensão de lista aninhada é computada no contexto da cláusula for seguinte, portanto o exemplo acima equivale a:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> transposed = []
				>>> for i in range(4):
				...     transposed.append([row[i] for row in matrix])
				...
				>>> transposed
				[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
				</code>
			</pre>
		</div>

		<p>e isso, por sua vez, faz o mesmo que isto:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> transposed = []
				>>> for i in range(4):
				...     # the following 3 lines implement the nested listcomp
				...     transposed_row = []
				...     for row in matrix:
				...         transposed_row.append(row[i])
				...     transposed.append(transposed_row)
				...
				>>> transposed
				[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
				</code>
			</pre>
		</div>

		<p>Na prática, você deve dar preferência a funções embutidas em vez de expressões complexas. A função zip() resolve muito bem este caso de uso:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> list(zip(*matrix))
				[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]	
				</code>
			</pre>
		</div>

		<p>Veja <a href="https://docs.python.org/pt-br/3/tutorial/controlflow.html#tut-unpacking-arguments">Desempacotando listas de argumentos</a> para entender o uso do asterisco neste exemplo.</p>

		<h3 id="5.2">5.2. A instrução del<a class="a-indice" href="#i-5.2"><sub>&nbsp;índice</sub></a></h3>
		<p>Existe uma maneira de remover um item de uma lista usando seu índice no lugar do seu valor: a instrução del. Ele difere do método pop() que devolve um valor. A instrução del pode também ser utilizada para remover fatias de uma lista ou limpar a lista inteira (que fizemos antes atribuindo uma lista vazia à fatia a[:]). Por exemplo:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
				>>> del a[0]
				>>> a
				[1, 66.25, 333, 333, 1234.5]
				>>> del a[2:4]
				>>> a
				[1, 66.25, 1234.5]
				>>> del a[:]
				>>> a
				[]	
				</code>
			</pre>
		</div>
		
		<p>del também pode ser usado para remover totalmente uma variável:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> del a
				</code>
			</pre>
		</div>

		<p>Referenciar a variável a depois de sua remoção constitui erro (pelo menos até que seja feita uma nova atribuição para ela). Encontraremos outros usos para a instrução del mais tarde.</p>

		<h3 id="5.3">5.3. Tuplas e Sequências<a class="a-indice" href="#i-5.3"><sub>&nbsp;índice</sub></a></h3>
		<p>Vimos que listas e strings têm muitas propriedades em comum, como indexação e operações de fatiamento. Elas são dois exemplos de sequências (veja Tipos sequências — list, tuple, range). Como Python é uma linguagem em evolução, outros tipos de sequências podem ser adicionados. Existe ainda um outro tipo de sequência padrão na linguagem: a tupla.</p>

		<p>Uma tupla consiste em uma sequência de valores separados por vírgulas, por exemplo:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> t = 12345, 54321, 'hello!'
				>>> t[0]
				12345
				>>> t
				(12345, 54321, 'hello!')
				>>> # Tuples may be nested:
				... u = t, (1, 2, 3, 4, 5)
				>>> u
				((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
				>>> # Tuples are immutable:
				... t[0] = 88888
				Traceback (most recent call last):
				  File "<stdin>", line 1, in <module>
				TypeError: 'tuple' object does not support item assignment
				>>> # but they can contain mutable objects:
				... v = ([1, 2, 3], [3, 2, 1])
				>>> v
				([1, 2, 3], [3, 2, 1])
				</code>
			</pre>
		</div>

		<p>Como você pode ver no trecho acima, na saída do console as tuplas são sempre envolvidas por parênteses, assim tuplas aninhadas podem ser lidas corretamente. Na criação, tuplas podem ser envolvidas ou não por parênteses, desde que o contexto não exija os parênteses (como no caso da tupla dentro de uma expressão maior). Não é possível atribuir itens individuais de uma tupla, contudo é possível criar tuplas que contenham objetos mutáveis, como listas.</p>

		<p>Apesar de tuplas serem similares a listas, elas são frequentemente utilizadas em situações diferentes e com propósitos distintos. Tuplas são imutáveis, e usualmente contém uma sequência heterogênea de elementos que são acessados via desempacotamento (ver a seguir nessa seção) ou índice (ou mesmo por um atributo no caso de namedtuples). Listas são mutáveis, e seus elementos geralmente são homogêneos e são acessados iterando sobre a lista.</p>

		<p>Um problema especial é a criação de tuplas contendo 0 ou 1 itens: a sintaxe usa certos truques para acomodar estes casos. Tuplas vazias são construídas por um par de parênteses vazios; uma tupla unitária é construída por um único valor e uma vírgula entre parênteses (não basta colocar um único valor entre parênteses). Feio, mas funciona. Por exemplo:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> empty = ()
				>>> singleton = 'hello',    # <-- note trailing comma
				>>> len(empty)
				0
				>>> len(singleton)
				1
				>>> singleton
				('hello',)
				</code>
			</pre>
		</div>

		<p>A instrução <code class="p-code">t = 12345, 54321, 'bom dia!'</code> é um exemplo de empacotamento de tupla: os valores <code class="p-code">12345, 54321 e 'bom dia!'</code> são empacotados em uma tupla. A operação inversa também é possível:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> x, y, z = t
				</code>
			</pre>
		</div>

		<p>Isso é chamado, apropriadamente, de sequência de desempacotamento e funciona para qualquer sequência no lado direito. O desempacotamento de sequência requer que haja tantas variáveis no lado esquerdo do sinal de igual, quanto existem de elementos na sequência. Observe que a atribuição múltipla é, na verdade, apenas uma combinação de empacotamento de tupla e desempacotamento de sequência.</p>

		<h3 id="5.4">5.4. Conjuntos<a class="a-indice" href="#i-5.4"><sub>&nbsp;índice</sub></a></h3>
		<p>Python também inclui um tipo de dados para conjuntos, chamado set. Um conjunto é uma coleção desordenada de elementos, sem elementos repetidos. Usos comuns para conjuntos incluem a verificação eficiente da existência de objetos e a eliminação de itens duplicados. Conjuntos também suportam operações matemáticas como união, interseção, diferença e diferença simétrica.</p>

		<p>Chaves ou a função set() podem ser usados para criar conjuntos. Note: para criar um conjunto vazio você precisa usar set(), não {}; este último cria um dicionário vazio, uma estrutura de dados que discutiremos na próxima seção.</p>

		<p>Uma pequena demonstração:<p/>

		<div class="exemplo">
			<pre>
				<code>
				>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
				>>> print(basket)                      # show that duplicates have been removed
				{'orange', 'banana', 'pear', 'apple'}
				>>> 'orange' in basket                 # fast membership testing
				True
				>>> 'crabgrass' in basket
				False

				>>> # Demonstrate set operations on unique letters from two words
				...
				>>> a = set('abracadabra')
				>>> b = set('alacazam')
				>>> a                                  # unique letters in a
				{'a', 'r', 'b', 'c', 'd'}
				>>> a - b                              # letters in a but not in b
				{'r', 'd', 'b'}
				>>> a | b                              # letters in a or b or both
				{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
				>>> a & b                              # letters in both a and b
				{'a', 'c'}
				>>> a ^ b                              # letters in a or b but not both
				{'r', 'd', 'b', 'm', 'z', 'l'}
				</code>
			</pre>
		</div>

		<p>Da mesma forma que compreensão de listas, compreensões de conjunto também são suportadas:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> a = {x for x in 'abracadabra' if x not in 'abc'}
				>>> a
				{'r', 'd'}
				</code>
			</pre>
		</div>

		<h3 id="5.5">5.5. Dicionários<a class="a-indice" href="#i-5.5"><sub>&nbsp;índice</sub></a>
</h3>
		<p>Outra estrutura de dados muito útil embutida em Python é o dicionário, cujo tipo é dict (ver Tipo mapeamento — dict). Dicionários são também chamados de “memória associativa” ou “vetor associativo” em outras linguagens. Diferente de sequências que são indexadas por inteiros, dicionários são indexados por chaves (keys), que podem ser de qualquer tipo imutável (como strings e inteiros). Tuplas também podem ser chaves se contiverem apenas strings, inteiros ou outras tuplas. Se a tupla contiver, direta ou indiretamente, qualquer valor mutável, não poderá ser chave. Listas não podem ser usadas como chaves porque podem ser modificadas internamente pela atribuição em índices ou fatias, e por métodos como append() e extend().</p>

		<p>Um bom modelo mental é imaginar um dicionário como um conjunto não-ordenado de pares chave:valor, onde as chaves são únicas em uma dada instância do dicionário. Dicionários são delimitados por chaves: <code class="p-code">{}</code>, e contém uma lista de pares chave:valor separada por vírgulas. Dessa forma também será exibido o conteúdo de um dicionário no console do Python. O dicionário vazio é <code class="p-code">{}</code>.</p>

		<p>As principais operações em um dicionário são armazenar e recuperar valores a partir de chaves. Também é possível remover um par chave:valor com o comando <code class="p-code">del</code>. Se você armazenar um valor utilizando uma chave já presente, o antigo valor será substituído pelo novo. Se tentar recuperar um valor usando uma chave inexistente, será gerado um erro.

		Executar <code class="p-code">list(d)</code> em um dicionário devolve a lista de todas as chaves presentes no dicionário, na ordem de inserção (se desejar ordená-las basta usar a função <code class="p-code">sorted(d))</code>. Para verificar a existência de uma chave, use o operador in.</p>

		<p>A seguir, um exemplo de uso do dicionário:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> tel = {'jack': 4098, 'sape': 4139}
				>>> tel['guido'] = 4127
				>>> tel
				{'jack': 4098, 'sape': 4139, 'guido': 4127}
				>>> tel['jack']
				4098
				>>> del tel['sape']
				>>> tel['irv'] = 4127
				>>> tel
				{'jack': 4098, 'guido': 4127, 'irv': 4127}
				>>> list(tel)
				['jack', 'guido', 'irv']
				>>> sorted(tel)
				['guido', 'irv', 'jack']
				>>> 'guido' in tel
				True
				>>> 'jack' not in tel
				False
				</code>
			</pre>
		</div>

		<p>O construtor dict() produz dicionários diretamente de sequências de pares chave-valor:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
				{'sape': 4139, 'guido': 4127, 'jack': 4098}
				</code>
			</pre>
		</div>

		<p>Além disso, as compreensões de dicionários podem ser usadas para criar dicionários a partir de expressões arbitrárias de chave e valor:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> {x: x**2 for x in (2, 4, 6)}
				{2: 4, 4: 16, 6: 36}
				</code>
			</pre>
		</div>

		<p>Quando chaves são strings simples, é mais fácil especificar os pares usando argumentos nomeados no construtor:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> dict(sape=4139, guido=4127, jack=4098)
				{'sape': 4139, 'guido': 4127, 'jack': 4098}
				</code>
			</pre>
		</div>

		<h3 id="5.6">5.6. Técnicas de iteração<a class="a-indice" href="#i-5.6"><sub>&nbsp;índice</sub></a></h3>
		<p>Ao iterar sobre dicionários, a chave e o valor correspondente podem ser obtidos simultaneamente usando o método items().</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
				>>> for k, v in knights.items():
				...     print(k, v)
				...
				gallahad the pure
				robin the brave
				</code>
			</pre>
		</div>

		<p>Ao iterar sobre sequências, a posição e o valor correspondente podem ser obtidos simultaneamente usando a função enumerate().</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> for i, v in enumerate(['tic', 'tac', 'toe']):
				...     print(i, v)
				...
				0 tic
				1 tac
				2 toe	
				</code>
			</pre>
		</div>

		<p>Para percorrer duas ou mais sequências ao mesmo tempo, as entradas podem ser pareadas com a função zip().</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> questions = ['name', 'quest', 'favorite color']
				>>> answers = ['lancelot', 'the holy grail', 'blue']
				>>> for q, a in zip(questions, answers):
				...     print('What is your {0}?  It is {1}.'.format(q, a))
				...
				What is your name?  It is lancelot.
				What is your quest?  It is the holy grail.
				What is your favorite color?  It is blue.
				</code>
			</pre>
		</div>

		<p>Para percorrer uma sequência em ordem inversa, chame a função reversed() com a sequência na ordem original.</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> for i in reversed(range(1, 10, 2)):
				...     print(i)
				...
				9
				7
				5
				3
				1
				</code>
			</pre>
		</div>

		<p>Para percorrer uma sequência de maneira ordenada, use a função sorted(), que retorna uma lista ordenada com os itens, mantendo a sequência original inalterada.</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
				>>> for i in sorted(basket):
				...     print(i)
				...
				apple
				apple
				banana
				orange
				orange
				pear					
				</code>
			</pre>
		</div>

		<p>Usar set() em uma sequência elimina elementos duplicados. O uso de sorted() em combinação com set() sobre uma sequência é uma maneira idiomática de fazer um loop sobre elementos exclusivos da sequência na ordem de classificação.</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
				>>> for f in sorted(set(basket)):
				...     print(f)
				...
				apple
				banana
				orange
				pear
				</code>
			</pre>
		</div>

		<p>Às vezes é tentador alterar uma lista enquanto você itera sobre ela; porém, costuma ser mais simples e seguro criar uma nova lista.</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> import math
				>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
				>>> filtered_data = []
				>>> for value in raw_data:
				...     if not math.isnan(value):
				...         filtered_data.append(value)
				...
				>>> filtered_data
				[56.2, 51.7, 55.3, 52.5, 47.8]
				</code>
			</pre>
		</div>

		<h3 id="5.7">5.7. Mais sobre condições<a class="a-indice" href="#i-5.7"><sub>&nbsp;índice</sub></a></h3>
		<p>As condições de controle usadas em <code class="p-code">while</code> e <code class="p-code">if</code> podem conter quaisquer operadores, não apenas comparações.

		<p>Os operadores de comparação <code class="p-code">in</code> e <code class="p-code">not in</code> são testes de associação que determinam se um valor está (ou não) em um contêiner. Os operadores são e não comparam se dois objetos são realmente o mesmo objeto. Todos os operadores de comparação têm a mesma prioridade, que é inferior à de todos os operadores numéricos.</p>

		<p>Comparações podem ser encadeadas: Por exemplo <code class="p-code">a < b == c</code> testa se a é menor que b e também se <code class="p-code">b</code> é igual a <code class="p-code">c</code>.</p>

		<p>Comparações podem ser combinadas através de operadores booleanos <code class="p-code">and</code> e <code class="p-code">or</code>, e o resultado de uma comparação (ou de qualquer outra expressão), pode ter seu valor booleano negado através de <code class="p-code">not</code>. Estes possuem menor prioridade que os demais operadores de comparação. Entre eles, not é o de maior prioridade e or o de menor. Dessa forma, a condição A and not <code class="p-code">B</code> or <code class="p-code">C</code> é equivalente a <code class="p-code">(A and (not B))</code> or <code class="p-code">C</code>. Naturalmente, parênteses podem ser usados para expressar o agrupamento desejado.</p>

		<p>Os operadores booleanos <code class="p-code">and</code> e <code class="p-code">or</code> são operadores curto-circuito: seus argumentos são avaliados da esquerda para a direita, e a avaliação encerra quando o resultado é determinado. Por exemplo, se <code class="p-code">A</code> e <code class="p-code">C</code> são expressões verdadeiras, mas B é falsa, então A and B and C não chega a avaliar a expressão <code class="p-code">C</code>. Em geral, quando usado sobre valores genéricos e não como booleanos, o valor do resultado de um operador curto-circuito é o último valor avaliado na expressão.</p>

		<p>É possível atribuir o resultado de uma comparação ou outra expressão booleana para uma variável. Por exemplo:</p>

		<div class="exemplo">
			<pre>
				<code>
				>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
				>>> non_null = string1 or string2 or string3
				>>> non_null
				'Trondheim'
				</code>
			</pre>
		</div>

		<p>Observe que no Python, ao contrário de C, a atribuição dentro de expressões deve ser feita explicitamente com o operador morsa <code class="p-code">:=</code>. Isso evita uma classe comum de problemas encontrados nos programas <code class="p-code">C:</code> digitar <code class="p-code">=</code> em uma expressão quando <code class="p-code">==</code> era o planejado.</p>

		<h3 id="5.8">5.8. Comparando sequências e outros tipos<a class="a-indice" href="#i-5.8"><sub>&nbsp;índice</sub></a></h3>
		<p>Objetos sequência podem ser comparados com outros objetos sequência, desde que o tipo das sequências seja o mesmo. A comparação utiliza a ordem lexicográfica: primeiramente os dois primeiros itens são comparados, e se diferirem isto determinará o resultado da comparação, caso contrário os próximos dois itens serão comparados, e assim por diante até que se tenha exaurido alguma das sequências. Se em uma comparação de itens, os mesmos forem também sequências (aninhadas), então é disparada recursivamente outra comparação lexicográfica. Se todos os itens da sequência forem iguais, então as sequências são ditas iguais. Se uma das sequências é uma subsequência da outra, então a subsequência é a menor. A comparação lexicográfica de strings utiliza codificação Unicode para definir a ordenação. Alguns exemplos de comparações entre sequências do mesmo tipo:</p>

		<div class="exemplo">
			<pre>
				<code>
				(1, 2, 3)              < (1, 2, 4)
				[1, 2, 3]              < [1, 2, 4]
				'ABC' < 'C' < 'Pascal' < 'Python'
				(1, 2, 3, 4)           < (1, 2, 4)
				(1, 2)                 < (1, 2, -1)
				(1, 2, 3)             == (1.0, 2.0, 3.0)
				(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)
				</code>
			</pre>
		</div>

		<p>Note que comparar objetos de tipos diferentes com < ou > é permitido desde que os objetos possuam os métodos de comparação apropriados. Por exemplo, tipos numéricos mistos são comparados de acordo com os seus valores numéricos, portanto 0 é igual a 0.0, etc. Em caso contrário, ao invés de fornecer uma ordenação arbitrária, o interpretador levantará um <code class="p-code">TypeError</code>.</p>


		<blockquote>
		Notas de rodapé <br>
		1 Outras linguagens podem retornar o objeto modificado, o que permite encadeamento de métodos, como <code class="p-code">d->insert("a")->remove("b")->sort();</code>.</blockquote>

	</main>
</body>

		<!--

		<div class="exemplo">
			<pre>
				<code>

				</code>
			</pre>
		</div>

		<a class="a-indice" href="#i-"><sub>&nbsp;índice</sub></a>

		<code class="p-code">
		-->

</html>
